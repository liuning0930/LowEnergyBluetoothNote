* Other
蓝牙支持IPV4和IPV6报文传输

网站：
1. 蓝牙技术联盟
http://www.bluetooth.org
2. 开发者网站
http://developer.bluetooth.org
3. 作者网站
http://www.37channels.com


* 一， 什么是低功耗蓝牙技术
BLE是当前可以用来设计和使用的功耗最低的无限技术
** 低成本：
1. ISM频段: 免交租金，免许可，但是传播特制差，能量极易被各类物体吸收。
2. IP许可: 加入BT SIG联盟，专利许可成本大大降低。
3. 低功耗: 减少制作材料。

** 设备类型: 双模设备和单模设备
双模设备：支持蓝牙和低功耗蓝牙
单模设备: 支持低功耗蓝牙
** 设计目标
最根本的目标就是实现最低的能耗。
对体系结构的每一层都进行了优化，以降低执行任所需的能耗。
低功耗蓝牙对主机个协议也做了优化，主要是为了减少从连接建立到应用程序完成数据发送所需的时间。
还包含最初的目标：
1) 全球操作
2) 低成本
3) 鲁棒性(Robust)
4) 短距离
5) 低功耗
短距离有一些问题：
1) 低功耗蓝牙网络并不是一个蜂窝基站系统，而是一个人人的局域网。
2) 为了减少设备端的信号传输的能耗，接收方必须保持较高的灵敏度, 例如scan，write， read等。
* 二，基本概念
** 纽扣电池: 纽扣电池是低功耗蓝牙的主要设计目标。
** 能量即时间：时间即能量是贯穿低功耗蓝牙设计的另一个基本概念
鲁棒的设备发现要求至少有两个设备：一个用于寻找其他设备，一个或多个设备则处于可发现状态。
在低功耗蓝牙中，一个设备如果想被发现就必须每隔几秒发送三次短消息。

数据报文的长度很短，主要是下面3个原因：
1) 发送相同数据减少能量消耗。
2) 控制器消除了在一次数据传输中需要不断校准无线电的需求。由于无线电模块在传送或接受时不断发热，将改变硅芯片的特性，并因此改变传输频率。
   如果报文控制在较短的长度，则芯片没有足够的时间发热。
3) 短期、间歇性而非长期的取电令设备可以从一个纽扣电池获得更多的能量。
** 昂贵的内存
** 非对称设计
假如一个设备只有发射器，另一个设备只有接收器，则二者构成的网络成为非对称网络。
发射器只完成最基本的功能，大部分复杂的功能运算都交给接收器。
** 为成功而设计
** 凡事皆有状态
** 客户端-服务器架构
** 模块化架构
基于通用属性规范的模块化的服务器架构，允许设备以标准的方式将原子的、可封装的行为比特装进单个服务并将其公开。
** 十亿只是个小数目
** 无连接模型
** 范式
1. 客户端-服务器架构
2. 面向服务的架构

*** 客户端-服务器架构
客户端通过网络想服务器发送请求，服务器回复响应。二者分工明确，当系统的不同部分位于不同的设备上时，这种划分必不可少。
*** 面向服务的架构
客户端-服务器架构之上的进一步抽象，将服务器中的信息组织成服务的模型。
该服务可以被发现，进行交互和用做已知的语义。这意味着改服务具有确定的行为，在给定相同的条件时，总会产生同样的结果。
服务具有一套规则和惯例：
1. 正式合约
   一个服务之所以被视为服务，是因为其在公开的功能以及如何工作两个方面提供正规的描述。
2. 松耦合
   在面向对象的软件中，单独的系统组件是被设计成无边界效应的独立对象。那些发生在组件之间的相互作用可以被明确地定义和测试。
   将依赖关系减少到最低限度，使修改服务的实现时不会带来意想不到的边界效应，从而降低风险。
3. 抽象化
4. 可重用性
5. 无状态
   为了让众多的客户端支持服务扩展，服务器不能保存任何客户端的状态数据。
6. 可组合型
7. 自治
8. 可发现性
   要想使用服务就必须能够发现服务。
   低功耗蓝牙采用的方法：使用同一个协议实现服务发现以及服务交互。
   
* 三，低功耗蓝牙的体系结构
低功耗蓝牙的体系结构本质上非常简单：
1. 控制器 
   控制器通常是一个物理设备，它能够发送和接收无线电信号，并懂得如何将这些信号翻译成携带信息的数据包。
2. 主机 
   主机通常是一个软件栈，管理两台或多台设备间如何通信以及如何利用无线电同时提供几种不同服务。
3. 应用程序
   实现用户需求
   file:images/BTArch.png
** 控制器 
蓝牙控制器同时包含了数字和模拟部分射频器件和负责收发数据包的硬件组成。
*** 物理层
物理层采用2.4GHz无线电，完成间距的传输和接收工作部分。
在低功耗蓝牙中，采用一种称为高斯频移键控(GESK)的调制方式改变无线电波的频率，传输0或1的信息。
*** 链路层
即Link Layer，是BLE中最复杂部分，负责广播、扫描、建立和维护连接，以及确保数据包按照正确的方式组织、正确地计算校验值以及加密序列等。其定义了三个基本概念：信道、报文、过程。
链路层信道分为两种：广播信道和数据信道
广播信道有3个，37.38.39。 未建立连接的设备使用广播信道发送数据。
数据信道有37个， 由一个自适应跳频引擎控制以实现鲁棒性。在数据信道中，可以发送数据，需要时可以重传，还可以加密和认证。
数据包结构：
|    1 |       4 |    1 |    1 | 0~37 |  3 |
| 前导 | 接入地址 | 抱头 | 长度 | 数据  | CRC |
*** HCI层
主机/控制器接口（HCI）的出现 为主机提供了一个与控制器通信的标准接口。允许主机将命令和数据发送到控制器，并且允许控制器将事件和数据发送到主机。主机/控制器接口实际上由两个独立的部分组成：逻辑接口和物理接口。 
逻辑接口定义命令、事件及其相关的行为。 
物理接口定义了包括命令、事件和数据通过不同的连接技术传输。已知定义的物理接口包括USB、SDIO、两个UART的变种。 
因为主机控制器接口存在控制器和主机之内，位于控制器中的部分通常为主机控制器接口的下层部分；位于主机中的部分通常称为主机控制器的上层部分。
** 主机
主机包含复用层、协议和用来实现许多有用而且有趣的过程。
*** L2CAP层 (Logical Link Control and Adaptation Protocol)
逻辑链路控制和适配协议（L2CAP）是低功耗蓝牙的复用层。该层定义了两个最基本的概念：L2CAP信道和L2CAP命令,L2CAP信道是一个双向的数据通道，通向对端设备上的某一特定的协议和规范。每个通道都是独立的，可以有自己的流量控制和与其相关联的配置信息。 
低功耗蓝牙只用了两个信道：一个用于信令信道，一个用于安全管理器，还有一个用于属性协议。低功耗蓝牙只有一种帧格式，即B帧，包含两个字节的长度字段和两个字节的的信道识别字符。**如图表，**B帧格式和传统的L2CAP的每个通道使用的基本帧格式一致，在协商使用一些更复杂的帧格式之前，传统L2CAP会一直使用该帧格式。
--------------------- 
使用的固定信道：信令信道（signal channel），安全管理器信道（SMP），属性协议信道（ATT）。
报文结构：
|    2 |      2 | 0~65535 |
| 长度 | 信道ID | payload |
*** 属性协议
属性协议定义了访问对端设备上的数据的一组规则。数据存储在属性服务器的”属性“里，供属性客户端执行读写操作。

1. 在低功耗蓝牙的设计之初，使用什么样的协议就成为了一个难题。协议应当十分简单，因为任何的复杂性都会增加额外的成本和所需的存储空间；同时，协议的数量要越少越好。由此，有人认为使用一种单一的、普适的协议在该技术的起步阶段是最佳的选择。不过这个想法并没有完全实现。低功耗蓝牙最后使用了三种协议：逻辑链路控制和适配协议(L2CAP)，安全管理协议(SM)和属性协议(AP)。精简协议：所有的计算乃至世上的大部分事物都围绕着协议运转。大多数的行为有其自身的协议，例如：载入网页用到了超文本传输协议(HTTP)；传输文件用到了文件传输协议(FTP)；安全的登陆另一台电脑，用到了安全外壳协议( SSH)。每一种协议都专攻于它自己的应用场合，试想要是用HTTP协议传输大量的文件，或是用FTP拇议登录电脑，那显然是欠缺效率的。低功耗蓝牙技术和成堆的因特网协议的最大区别在于，低功耗蓝牙技术并不试图传输多样化的数据类型。考虑到不会用来传输大批量的数据或是流媒体音乐，为其开发一种能够处理有限的几种数据类型的协议就可以。这种协议被称为属性协议，是整个蓝牙技术的基石和构造组件。只有理解了属性协议才能理解低功耗蓝牙技术。

2. 数据与状态：还有一个需要理解的概念是：数据( data)与状态（state）这两者有着显著的差别。数据是一个值，它反映了某种客观性质，比如某种测量的结果、读数。数据可以是温度计涮出的房间温度，也可以是供暖系统测出的室内温度；它们都可以被不同的设备测量出来。而状态则反映了某个设备的当前状况或处境：它在做什么、是怎么运作的。设备的状态只有它自己知道，并靠自身维持。温控器测量室温，温度的度数则反映了房间温度的状态。几种常见的状态：低功耗蓝牙用到了三种不同种类的状态类型：外部状态、内部状态与抽象状态。物理测量值反映了物理传感器或者类似接口的当前状态+让我们设想一个浴室里的体重计。

3. 状态机：有趣的是，有限状态机可以明确地使用属性协议和可公开的状态来表示。状态机反映了设备的内部状态，并且有一个或多个外部的辅人接口。这些外部辅人为瞬时命令，根据其他状态信息或行为来改变状态机的状态。这是一个抽象状态，或称为控制点。

4. 服务和规范：从经典蓝牙到低功耗蓝牙，最有趣的转变是服务和规范的体系结构。经典蓝牙里的规范和协议大多定义的是行为与交互指南，它们极其复杂，糅合了许许多多不同的概念。其中，一个最大的问题是这些规范倪定义了两种设备类型，位于链路的两端，再对各自的行为分别定义。粗略地看来，这种做法似乎很有必要：好比体有一部手机和车载（免提）套件，我们必须基于具体应用为其定义各自的工作方式以及交互方式。不幸的是，这也造成了一些麻烦。首当其冲的问题在于，现有的规范对网络中的设备自身的行为定义不够明确。换言之，即便看起来两个设备都定义了各自的行为，但有时候设备自身到底应该怎么做其实并不清楚。低功耗蓝牙使用了一种截然不同的方法来解决上述问题。首先，它采用了纯粹的“客户端一服务器”的结构，针对不同的用例对服务器和客户端的行为单独进行描述。服务器的行为在服务器规格书中定义，而用户的行为在另一规范说明中定义。通过一个属性数据库，服务器规格书定义了需要公开的状态以及通过属性可以实现的行为。将服务器和客户端区分开的最大的好处是，服务器的行为将是预先定义并可知的。它只会做服务说明中定义的“该做”的事情，不会关心客户端将怎样去使用它。这意味着服务可以独立执行单元测试，而与客户端无关；任何客户端可以在必要的时候使用这些服务。举个例子，假设有一种提供时间的服务，某个客户端可用其获取当前时间；另一个客户端周期性地读取当前时间来判断自身的时钟漂移；其他客户端还可以请求其使用GPS接收机以便获得最精确的授时。你瞧，这个时间服务并不关心客户端在做什么，它仅仅提供该服务罢了。

*** 通用属性规范
通用属性规范位于属性协议之上，定义了属性的类型以及其使用方法。它引入了一些概念，包括“特征”、”服务“、服务之间的”包含“关系、特性”描述符“等。
它还定义了一些规程，用来发现服务、特性、服务之间的关系，以及用来读取和写入特性值。

服务间的关系是可以相互组合，实现更为复杂的行为。为了适应复杂的行为和服务之间的关系，服务分为首要服务和次要服务。
*** 通用访问规范
通用属性规范定义了设备如何发现、连接，以及为用户提供有用的信息。还定义了设备之间如何建立长久的关系，成为绑定（binding)。
** 应用层
应用层规约定义了三种类型：特性(characteristic)、服务(service)、规范(profile)。
* 四、物理层
** 2.4GHz
低功耗蓝牙采用2.4GHz 工业、科学及医疗(ISM)频段传输信息。这个频段有2个特殊之处：
1. 不需要授权
2. 唯一一个在所有国家都无需授权的频段
** 调制
低功耗蓝牙采用了高斯频移键控。高斯滤波器通过增加从一个值到另一个值的频率转换时间，优化了一个符号到下一个符号的转换，减少噪声，减少发射功率。
低功耗蓝牙的物理层比特率为1Mbps，调制指数约为0.5。
** 射频信道
低功耗蓝牙传输信息使用40个无线信道，每个信道的中心频率可以根据简单算术算出：
             fc = 2402 + 2k
             [[file:images/channels.png]]
** 距离
理论上BLE的通信距离可以达到几百米远，但主要还是根据发射功率和接收机灵敏度决定的,我用的时候也就10米之内喽。
* 五、链路层
链路层定义了两个设备如何利用无线电传输信息。它包含了报文，广播，数据信道的详细定义，也定义了其他设备的流程，广播的数据，连接的建立，连接的管理以及连接中的数据传输。
** 链路层的状态机
链路层的状态机定义了5中状态：
1. 就绪态
2. 广播态
3. 扫描态
4. 发起态
5. 连接态
由上面可以看出，低功耗蓝牙另一个基本设计策略：将广播、发现和连接过程与连接中的数据传输分离开来。
只有在连接态中使用数据报文，广播态、扫描态、发起态使用广播报文。
连接态有2个子状态：主或从。在连接态中，2个设备相互传送数据信道报文。
另外，链路层是一个“独裁者”，如果成为了主设备，便不能同时成为从设备。类似地，从设备也不能同时成为主设备。这也意味着主设备不能发送可用于连接的广播报文。
** 报文
低功耗蓝牙规范中，有两类报文：广播报文和数据报文。是广播报文还是数据报文由其传输所在的信道决定的。
总的数据图：
[[file:images/packageformat.png]]
*** 白化
频移键控接收机的一个有趣之处在于，其连续接收相同比特的能力很差。例如“0000000000”，这时候接收机会认为中心频率向左移动，进而导致频率失锁，丢失数据。
白化器是一个很短的输出“0”，“1”序列的随机数发生器，与原有数据进行异或操作，在通过白化序列逐位异或还原。
通过使用随机白化器，原始信息中的一段比特会被转化成一段高度随机化的序列。这降低了接收机评率失所的概率。如果原始数据信息已经是随机的，进一步的随机化一般也没什么坏处。
*** 报文结构
数据包结构：单位bit
|    8 |       32 |    8 |    8 | 0~296 |  24 |
| 前导 | 接入地址 | 抱头 | 长度 | 数据  | CRC |
1. 比特序与字节
   报文是一比特一比特传输的，但他们同时也是由数据的字节组成的。当数据的字节传输时，总是从最低位开始。
2. 前导
   接收机用它来配置自动增益控制，以及确定“0”，“1”比特所使用的频率。
   自动增益控制器必须检测出输入信号的能量等级，并调整增益，使得信号刚好处于接收机能够轻松工作的范围之中。
3. 接入地址
   报文接下来的32比特是接入地址。两种类型：
   * 广播接入地址
   * 数据接入地址
   广播接入地址在广播数据，或是广播、扫描、发起连接时使用。数据接入地址在连接建立之后的两个设备间使用。
   当控制器试图接收一个报文时，需要事先知道待接收报文的接入地址，减少噪声。
   链路层也不知道其他设备啥时候发送报文，只能保留40us接收到的比特，和前导、接入地址进行匹配。这一过程称为与接入地址相关。
   对于广播信道，接入地址是固定值 0x8E89BED6。
   接入地址最基本的规则是不能有超过6个连“0”或”1“。数据信道接入地址与广播信道接入地址至少要有1个比特的不同。
4. 报头
   报头包含了广播报文的类型以及一些标记位，这些标记位指出了报文使用的公共地址还是随机地址。
   | Tyep            | Behavior     |
   | ADV_IND         | 通用广播提示 |
   | ADV_DIRECT_IND  | 定向连接指示 |
   | ADV_NONCONN_IND | 不可连接指示 |
   | ADV_SCAN_IND    | 可扫描指示   |
   | SCAN_REQ        | 主动扫描指示 |
   | SCAN_REP        | 主动扫描响应 |
   | CONNECT_REQ     | 连接请求     |
5. 长度
   对于广播报文。长度域包含6个比特，有效值的范围是6~37。对于数据报文。长度域5个比特，有效值的范围是0~31。
   长度域后是payload，其长度是长度域指出的字节数。
6. payload
   传输的真实数据。
7. CRC
   CRC对报头、长度域以及payload进行计算，检查是否错误。
*** 信道
低功耗蓝牙的信道宽度为2MHz, 经典蓝牙是1MHz。
1. 跳频
   跳频算法用于数据连接中。数据信道37个，是一个质数，因此跳频算法非常简单：
   f(n+1) = (f(n) + hop) mod 37  //hop（5~16）
2. 自适应跳频
   自适应跳频能够将一个已知的坏信道映射到一个已知的好信道，从而减少其他设备对数据报文传送的干扰。连接中的两个设备都要记录好、坏信道的映射关系
   来调整信道。
*** 设备发现
低功耗蓝牙设备通过广播信道来发现其他设备。共有4种不同类型的广播：通用的，定向的，不可连接的以及可发现的。
设备每次广播时，会在3个广播信道上发送相同的报文。这些报文被称为一个广播事件。除了定向报文以外，其他广播事件可以选20ms~10.28s的间隔。
通常，一个广播中的设备会每秒广播一次。广播事件之间的时间间隔称为广播间隔，主机可以配置它。
但是，设备周期性的发送广播会有一个问题：由于设备的时钟会不同程度的漂移，两个设备可能在很长一段时间同事广播而造成干扰。除了定向广播之外的其他广播事件，
发送时间均会被扰动。实现该扰动的方式为，在上一次广播事件发送后加入0~·0ms的随机延迟。

扫描是低功耗蓝牙广播的重要组成部分。扫描用于接收广播事件。扫描时间取决于有多少时间用于扫描以及需要多块发现其他设备。
**** 通用广播
通用广播是用途最广的广播方式。进行通用广播的设备能够被扫描设备扫描到，或者在接收到连接请求时作为从设备进入一个连接。通用广播可以在没有连接的情况下发出，没有主从设备之分。
**** 定向广播
当设备之间需要快速建立连接的时候，就要用到定向广播。
这种报文包含两个地址：广播着的地址和发起者的地址。(在iPhone手机上，每15分钟改变它自己的地址, 是个大限制)
发起设备收到发给自己的定向广播报文后，可以立即发送连接请求作为回应。
定向广播事件也有特殊的时序要求。完整的广播事件必须每3.75ms重复一次。这一要求使得扫描设备只需要扫描3.75ms便可以收到定向广播设备的消息。
如此快的发送会让报文充斥着广播信道，定向广播不可以持续1.28s以上的时间。一旦到了1.28，主机便只能使用间隔长得多的通用广播让其他设备来连接。
当使用定向广播时，设备不能被主动扫描。此外，定向广播报文的payload中也不能带有其他附加数据。该payload只能包含两个必需的地址，别无其他。
**** 不可连接广播
**** 可发现广播
该设备可以被发现，既可以广播数据，又可以响应扫描，但不能建立连接。
*** 广播
广播数据能够被附近的任何被动或主动扫描设备接收到。广播数据的接收无法被确认。广播设备无法知道时候有设备接收到它的数据，或者是否有设备试图侦听它的数据，是一种不可靠的操作。
*** 建立连接
连接使用数据信道在两个设备之间可靠地发送信息，采取了自适应跳频增强鲁棒性(robust),同时使用了非常低的占空比，尽可能地降低功耗。
设备创建连接的过程：
[[file:images/connection.png]]
设备首先广播可连接广播事件，其他设备收到后即可发起连接。
连接开始需包含的信息：
1. 连接中使用的接入地址
   由主设备提供，随机生成，需要遵循一些规则。
2. CRC初始值
   由主设备提供的随机数，可以保证主设备同不同的从设备通信。
3. 发送窗口大小 
4. 发送窗口偏移
5. 连接间隔
6. 从设备延迟
7. 监控超时
8. 自适应跳频信道图
9. 跳频算法增强
10. 休眠时钟精度

**** 发送窗口
  从设备可以自行决定广播时间，是最需要保存电量的设备。但是，如果主设备已经在做其他事情，也许是一些更重要的事情，那么它必须让低功耗蓝牙错开当前的活动。
   在连接建立期间，用窗口大小和窗口便宜传递上述信息。
   当连接请求数据包发送完毕，存在一个1.25ms的强制时延，紧接着是发送上述两个参数。发射窗口便宜可以是0到连线间隔之间的任意值，但必须为1.25ms的整数倍。
   从发送窗口开始，从设备打开其接收器，并等待来自主设备的数据包。如果到发送窗口结束时仍未收到数据包，从设备终止倾听，并会在一个连接的间隔后再次尝试。
 
  iOS由于系统封装的层很高，只需要进行扫描，连接，获取服务和特性后，进行读写操作。MTU大小和Interval都自动设备。
   Android相比较于iOS可以设置MTU大小，设置失败时候默认23。
**** 连接事件
   在一个连接当中，主设备会在每个连接事件里向从设备发送数据包。




*** 发送数据
在一个连接里，设备通过在连接事件中发送数据包来相互通信。数据报文和广播报文不同，前者是单独进行的通信，后者则是对所有的侦听设备发送广播。
广播报文和数据报文间最大的区别是报头的格式和payload的长度。
数据报文的payload可以为0~31字节不等。payload长度为0视为空包。
无论链路层加密与否，传给控制器的未加密数据包最多只能携带27个字节的数据。
**** 数据报头
   包含4个字段：
   * 逻辑链路标识符(LLID)
   * 序列号(SN)
   * 下一个预期序列号(NESN)
   * 更多数据(MD)
**** LLID
它用于判断数据报文属于哪种类型：
a. 链路层控制报文(11) ---- 用于管理连接
b. 高层报文(10) ---- 也用于一个完整报文
c. 高层报文延续(01)
数据包LLID为11，会直接交给链路层控制实体，由它来解析改数据包内容。

所有其他的数据包都要经过主机，要么来自主机，要么发给主机。 主机能够发送大于27字节的数据，但由于无法放入单个链路层的数据包，必须支持分段。
具体做法就是把数据包贴上“高层报文开始”或"高层报文继续"的标签。
**** SN
为了使数据传输变得可靠，所有的数据包均带有序列号。连接建立后，第一个数据包的序号为0；每次发送新的数据包时，其序列号与上个数据包的序列号不同。
这使得接收装置能够判断接收的数据包的性质：如果序列号与之前的一样，则为重传报文，如果序列号和之前的不同，则为新报文。
在数据包中，用一个比特来表示序列号，在1和0 之间交替。
**** 确认
数据包的确认需要用到另一个比特，即所谓的下一个期望序列号。
file:images/transmit.png
**** 更多数据
它用来通知对端设备自己还有其他的数据准备发送。如果收到了它，应该在当前连接事件中继续与端设备通信。
*** 加密
在连接时，可以对payload中的数据进行加密，确保数据的机密性，从而抵御攻击者。
后续仔细看。
*** 管理连接
两个设备一旦连接，便可以收发数据和管理连接。连接管理涉及在链路层发送控制消息，包含下列七个链路层控制规程：
| 更新连接参数
| 改变自适应跳频信道图
| 加密链路
| 重加密链路
| 交互功能位
| 交换版本信息
| 终止链路
**** 连接参数更新
连接建立时，主设备通过链接请求数据包发送连接参数。当连接活跃了一段时间，连接参数也许不再适用于当前使用的服务。出于提高效率的目的，连接参数需要进行更新。较之首先断开连接、接着更换新参数重新连接，还有一种在链路中更新参数更为简单的途径，如下图所示：
[[file:images/updata_l2cap.png]]
此，主设备向从设备发送连接更新请求，即LL_CONNECTION_UPDATE_REQ，当中携带了新的参数。这些参数不必进行协商，从设备或者接受和使用它们，或者断开链路。连接更新请求中包含了早先创建连接时用过的一部分参数，还有一个称为瞬时（instant）的新参数：
1.传输窗口大小
2.传输窗口偏移量
3.连接间隔
4.从设备延迟
5.监控超时
6.瞬时
瞬时参数决定了连接更新的开始时刻。发送消息时，主设备为连接更新选定一个未来的时间点，并且放在消息中。接到消息后，从设备会记住这个未来的时刻，届时再切换至新的连接参数。这有助于解决无线系统里的一个最大问题----报文重传。只要数据包的重传次数足够，并最终在瞬时之前传输成功，上述过程执行起来就不会有问题。但是，如果该数据包届时没能完成传输，链路就有可能丢失。
由于低功耗蓝牙没有时钟，要决定瞬时时刻只有依靠计算连接事件的个数。因此，每一个连接事件都会被计数，链路上的第一个连接事件，也就是在连接请求之后的位于首个传输窗口里的连接事件记为 0。因此，瞬时实际上是一个连接事件的计数器，相应的连接事件到来时就使用新的参数。为了让从设备收到数据包，主设备必须为其提供足够的机会。不过从设备延迟是多少，都应该至少保证 6 次数据发送机会。也就是说，如果从设备延迟为 500ms，那么瞬时通常被设定在 3s 之后的某个未来时刻。
瞬时到来时，从设备开始侦听发送窗口，就好像连接建立的过程那样。主设备能够调整从设备的计时，总体而言不超过 1.25ms。不过，由于主设备可能还是一个经典蓝牙设备，上述调整使其得以协调低功耗蓝牙从设备，从而更好地完成调度。一旦该过程结束，新的连接间隔、监控超时、从设备延迟值将投入使用。
**** 自适应跳频
[[file:images/update_channel.png]]
链路层控制规程不允许从设备改变信道图，甚至不能向主设备告知自身信道条件。
**** 启动加密
**** 重启加密
**** 版本交换
**** 功能交换
对端设备利用功能信息来判断本端设备到底能做些什么。
**** 终止连接
断开链路并把主从设备从连接态转为就绪态
要终止链路，设备首先发送一个终止指示报文(LL_TERMINATE_IND),等待链路层对该报文进行确认，然后断开连接。
可能还有其他原因造成：
1. 监控超时
2. MIC失效
*** 鲁棒性
链路层采用了两个强有力的算法以确保数据不受干扰地传输，以及从本端主机发送到对端主机时不发送变化。
1. 自适应跳频
2. 强CRC
   在低功耗蓝牙中，CRC值的长度要比经典蓝牙或者其他大部分短距离无线技术长50%。经典蓝牙是16位，低功耗采用24位。
* 六、主机/控制器接口
主机控制器接口(HCI)是主机与控制器之间，主要完成两个任务：一个是发送命令给控制器和接收来自控制器的事件，另一个是发送和接收来自对端设备的数据。
一般来说，主机接口既是两个设备之间的物理上的接口，也是逻辑上的接口。逻辑接口定义了命令、事件和数据的封包格式。而物理接口则规定了主机和控制器之间如何传输这些数据包。
** 物理接口
蓝牙规范里面定义了4种物理接口,每一种对应着不同的用途：
a. 通用异步收发器(URAT)提供了最简单的传输方式。
b. 3线URAT则提供可靠的UART传输方式。
c. USB为电脑和类似的设备提供高速的，通用的传输方式。
d. 安全数字输入和输出(SDIO)为消费电子设备提供中等速度的传输方式。
*** UART
通用异步收发器（UART）提供了最简单的传输方式。
UART接口中每一个HCI数据包有下列三种报文类型编码：
a. 命令(command)=0x01
b. 数据(data)=0x02
c. 事件(event)=0x04
UART接口不能在低电压的情况下进行信号收发，不适合低电压设备。
*** 3 线UART
它比UART更复杂，能减少误比特情况，具有更好的鲁棒性。
它的主要模式：
a. 链路建立
b. 活动状态
c. 低电压状态
*** USB
主要是为了拥有USB Host的设备而设计。
*** SDIO
高速并且能耗低，误码率也低。
** 逻辑接口
HCI物理传输接口就是逻辑接口中的一种。所谓的逻辑接口是指在单芯片设备上，不需要在组件之间真正实现这样的信息传输接口。
当系统中的控制器和主机分别位于两个芯片上，HCI逻辑接口就体现为在二者之间传输数据的物理接口。
它包含三个概念：
1. 信道(channel)
2. 数据包格式(packet format)
3. 流控(flow control)
*** HCI 信道
控制器与其他设备建立连接后，控制器的底层HCI接口就创建一个HCI信道，使用一个连接句柄(connection handle)来标识这个HCI信道。
连接句柄既用来标识主机交给控制器并准备发往对端的数据，又用来标识控制器从对端收到的准备交给主机的数据。
*** 命令数据包
主机通过向控制器发送命令数据包来执行命令。这些命令通常用于配置控制器的状态，或者请求控制器完成操作。
它包括：用来确认发送命令的操作码，参数长度字段和命令参数。每个命令都有自己独特的参数。
|      2 |        1 | 参数长度 |
| 操作码 | 参数长度 | 参数     |
低功耗蓝牙有三种基本命令类型：
a. 配置控制器的状态
b. 请求执行特定的操作
c. 管理连接
1. 配置控制器的状态
   可以将控制器视为一个大状态机，有一系列的参数可以进行配置。如果状态机正在使用，通常不能进行调整，要等结束后才行。
2. 请求指定操作
   一些命令可以请求控制器执行执行操作，但不会改变设备状态或连接状态。
3. 管理连接
   设备建立连接后，可以通过命令来管理连接。
*** 事件数据包
控制器发送主机的事件数据包主要用于发送信息和反馈之前的命令。
它包含事件类型编码、参数的长度字段和事件参数，每个事件都有一套独特的参数。
三种基本事件类型：
a. 通用命令完成事件
b. 通用命令状态事件
c. 特定命令完成事件

HCI事件数据包格式:
|            1 |        1 | 参数长度 |
| 事件类型编码 | 参数长度 | 参数     |

1. 通用命令完成事件
   当主机发送给控制器的命令执行完毕时，控制器立即返回一个通用命令完成事件。事件参数包含了之前发送的命令操作码和执行命令的返回参数。
   返回参数中的第一个参数是状态码，状态码用来标识命令执行成功与否。
2. 通用命令状态事件
3. 特定命令完成事件
   有些命令需要一段时间才能完成执行，它们都有对应的、并且是唯一的特定命令完成事件。
   需要注意的是，命令是否执行完毕并不以收到特定命令完成事件作为标志。
*** 数据包
HCI数据包格式：
|         2 |        1 | 数据长度 |
| 句柄\标记 | 数据长度 | 数据     |
数据包是指主机和控制器之间传输的应用数据。控制器接收来自主机的数据包，将其传给对端设备。对端设备收到数据之后，将其从控制器发往主机。
HCI数据包有两种标记(flags):数据包边界标记(Packet Boundary Flag)和广播标记(Broadcast Flag)。
数据包边界标记来确认上层协议L2CAP的信息是一个开始数据包还是一个延续包。
| 标识 | 主机->控制器 | 控制器->主机 |
| 开始 |           00 |           01 |
| 延续 |           10 |           01 |
*** 命令流控
有两种形式：命令流控和数据流控。
控制器使用命令流控同时处理多个HCI命令。因为控制器内部拥有足够的缓存，能够存储一定数量的命令；主机可以通过控制器来或者缓冲区的长度，从而得知可以同时发送的命令的最大数量。
HCI接口不支持事件流控。因为事件流控的数量受限于可处理命令的数量，另外主机比控制器拥有更多的资源，所以能够顺序地缓冲和处理这些事件。
*** 数据流控
有两种数据流：主机到控制器以及控制器到主机。主机到控制器的数据流控是必须的，而控制器到主机的流控可以忽略。
*** 控制器的配置
不多讲，太细，看资料或者书籍
https://blog.csdn.net/weixin_38491862/article/details/80597845
*** 广播和观察
两个低功耗蓝牙设备之间的最基本的通信模型就是广播(broadcasting)和观察(observing)模型，采用广播和扫描来传输数据。
**** 广播
控制器有两类数据可以通过广播发送：广播数据和扫描响应数据。
[[file:images/broadcast.png]]
**** 被动扫描
可以使用被动扫描接受对端设备的广播数据包。
控制器的可配置扫描参数如下:
a. 扫描类型
b. 扫描间隔
c. 扫描窗口
d. 扫描策越

扫描间隔和扫描窗口是两个非常重要的参数，因为他们决定了控制器的扫描频率和扫描时间的长短。他们共同决定控制器的扫描占空比，既扫描窗口与扫描间隔二者的比值。
[[file:images/unactiveScan.png]]
**** 主动扫描
即可捕获广播包，也可以捕获可能的扫描响应包
[[file:images/scan.png]]
** 发起连接
想要实现更多的功能必须依赖两个设备之间的连接。
当然，要建立连接，其中一个蓝牙设备应处于可连接的广播状态，由另一个设备发起连接。
连接对象可以白名单对象，指定的单一设备。
** 连接管理
建立连接后，设备就可以对连接进行管理，包括切换到低功耗模式、增加或减少间隔时间、设置加密或终止连接等。
*** 更新连接
若当前的连接参数不再适用时，主设备可以进行修改。比如修改interval，MTU等。
[[file:images/updateConnection.png]]
*** 更新信道映射图
控制器可以在任何时候启动链路层控制规程修改信道映射图。
[[file:images/updateChannelMap.png]]
*** 交换功能列表
主机可以获知当前连接所支持的功能。
[[file:images/exchangeFeatures.png]]
*** 交换版本信息
*** 加密连接
......
*** 重启加密
......
*** 终止连接
如果不再需要发送数据，或者维持连接比断开后再重新连接需要更多的能量时，主机可以终止连接。
[[file:images/closeConnection.png]]
* 七、逻辑链路控制和适配协议
逻辑链路控制和适配协议（L2CAP）是个复用层，可以让低功耗蓝牙复用三条不同的信道。支持数据的分割和重组功能，使得较大的报文可以在底层无线电中传输。
** 背景
和经典蓝牙完全不同，低功耗蓝牙的一个基本概念在于无连接模式。用户只在需要发送数据的时候才建立莲接，其他时候设备可以长期处于断开连接状态。为了实现该功能，无连接模式必须扩展到L2CAP层，并且只能使用固定信道。在低功耗蓝牙设计之初并未选择L2CAP，而是使用了另一个称为协议适配层（Protocol Adaptation Layer，PAL）的设计。PAL仅支持两种数据包：高层协议信令数据包以及自身的信令数据包。PAL不支持分割或重组，也没有区分不同协议的功能。协议设计的一个基本原则是每一层协议都是独立的。在经典蓝牙中，面向连接信道可以把某对单独的应用数据与其他信道的数据相分离。举个例子，虽然所有的面向连接信道都能添加额外的数据完整性检测，但它们可能有不同的流规范，或者隶属于流信道而非尽力交付信道。面向连接信道非常适合那些复杂的、多种数据同时传输的系统。比如手机既可以向汽车的立体声发送高质量的语音流，还可以发送电话簿、免提等。
*** L2CAP信道
L2CAP有个很简单的概念——信道。毕竟L2CAP是一种复用层，有多个信道也不足为怪。
信道是指一个数据包序列，连接两个设备上的一对服务。在两个设备间允许同时启用多条信道。低功耗蓝牙只支持固定信道。固定信道指的是两个设备一建立连接就已经存在的、没有任何配置参数的信道。
L2CAP信道标识符
|    信道标识符 | 用法               |
|        0x0000 | 保留：不能使用     |
|        0x0001 | 经典蓝牙信令信道   |
|        0x0002 | “无连接”信道       |
|        0x0003 | AMP管理协议        |
|        0x0004 | 属性协议           |
|        0x0005 | 低功耗信令信道     |
|        0x0006 | 安全管理协议       |
| 0x0007~0x003E | 保留：日后可能使用 |
|        0x003F | AMP测试协议        |
| 0x0040~0xFFFF | 面向连接信道       |
低功耗蓝牙一共使用了3个信道：信息标识符0x0004用于属性协议；信道0x0005用于低功耗蓝牙信令信道；信道0x0006用于安全管理。
*** L2CAP数据包结构
每个L2CAP数据包的净荷前端都包含一个32位比特报头。假设使用分割和重组，那么数据包的长度信息必须包含在报头中，以便判断数据包的结束。使用分割和重组机制需要为每个通过HCI接口的数据包打上标记，分为开始数据包或延续数据包。不过，这里没有定义怎样标记当前数据包的最后一个片段。意味着，判断当前数据包唯一方法是发送一个新的数据包，或者将数据包的长度信息放在开始数据包中。如下图所示，报头包括2字节的长度字段和2字节的信道标识符。长度字段表示报头后的信息载荷字节数。在经典蓝牙中，信息载荷还可以包含额外的报头和信息，但在低功耗蓝牙的L2CAP层中并没有其他有意义的信息结构。
|    2 |          2 | 0 ~ 65535       | 字节 |
| 长度 | 信道标识符 | Payload信息载荷 |      |
在所有低功耗蓝牙信道上，信息载荷均始于23字节的最大传输单元(MTU)。MTU表示一个L2CAP信道中信息载荷的最大字节数。
意味着所有低功耗蓝牙设备必须支持在空间传输27字节数据包-4字节为L2CAP报头，23字节信息载荷。
*** 低功耗信令信道
低功耗信令信道用于主机层级的信令。每个低功耗信令信道的数据包均含有一操作码，随后为各种参数。低功耗信令信道支持的命令操作码如下：
a. 命令拒绝（Command Reject）
b. 连接参数更新请求（Connection Parameter Update Request）
c. 连接参数更新响应（Connection Parameter Update Response】
无论什么时候发送信令命令，其信息载荷总是包含一标识符。改标识符仅1字节，用于匹配请求和响应。举例来说，如果请求的标识符是0x35，则响应该请求的数据包必须使用0x35为标识符。
如此一来，只要每个请求有不同的标识符，多个请求便能同时发送。同时确保在用完所有标识符前不能重复使用，也不能使用0x00标识符。
L2CAP命令数据包：
[[file:images/l2capcommand.png]]
**** 命令拒绝
用于拒绝设备收到的不支持的信息包。该命令与经典蓝牙中的命令拒绝完全一样。它包含一个原因代码以及相关信息。其中的原因代码可以是“命令不理解”或“信令MTU溢出”。
在设备收到了不支持的命令时可以使用“命令不理解”原因代码；当收到未定义的命令时也可以使用，这使得设备具有更好的兼容性。
**** 连接参数更新和请求的响应
可以让从设备更新链路层的连接参数，这些参数包括连接事件间隔（从设备希望主设备允许从设备发送数据包的频率）、从设备延迟（从设备能够忽略主设备的连接事件的最大值）以及监控超时。连接参数更新请求命令仅用于从设备向主设备发送，这是由于主设备随时都能启动链路层连接参数更新控制（ConnectionParameter Update Control）规程。如果该命令由主设备发送，从设备会将其视为一个错误，并返回带有“命令不理解”原因代码的“命令拒绝”命令。
[[file:images/l2capupdaterequest.png]]

* 八、属性
这里涉及协议栈的两个层次：属性层和通用属性规范层，二者密切相关。在蓝牙技术联盟(SIG)构建低功耗蓝牙时，属性协议的概念最初是在非核心的工作组里被提出，之后才被引入到核心规范中。
在属性协议集成到核心规范时，SIG做出一个架构性的决定：将其分割为一个抽象协议和一个通用配置文件。从协议的角度出发，抽象化本身是有帮助的，不过它对于理解属性的工作原理毫无用处。

** 背景
起初低功耗蓝牙采用三种协议：逻辑链路层控制和适配协议(L2CAP)，安全管理协议(SM)和属性协议(AP)。
随后的目标是尽可能减少协议的数量，让通用属性规范(GATT)之上的所有服务都是用属性协议，包括用来提供名字和存在发现的通用访问规范(GAP)，把在GATT上构建其他服务的成本降至最低。
*** 精简协议
低功耗蓝牙技术和成堆的因特网协议的最大区别在于,低功耗蓝牙技术并不试图传输多样化的数据类型。所以，为其开发一种能够处理有限的几种数据类型的协议就可以。这种协议被称为属性协议，是整个蓝牙技术的基石和构造组件。
*** 无所不在的数据
在人们最初探讨低功耗蓝牙技术时，显然当时所有的通信系统都和数据有关。许多事物都包含数据，低功耗蓝牙技术被其他设备接纳、使用这些数据的一种手段。数据可以是任何信息。
关于数据，这里需要理解一个重要概念：一些设备具有数据，另一些设备需要这些数据。这两种设在角色上的区别对于低功耗蓝牙来说尤为重要，因为它决定了谁是服务者，谁是客户。
提供数据的设备成为服务器，使用其他设备的数据的设备成为客户端。
*** 数据与状态
数据和状态是有显著差别的。数据是一个值，它反映了某种客观性质，比如某种测量的结果、读数，它们可以由不同设备测量出来，例如可以用多种方式知道当前温度等。
状态则反映了某个设备的当前状况或处境:它在做什么，是怎么运作的。设备的状态只有它自己知道，并靠自身维持。
在这里，“状态”指的事保存在服务器上的信息；“数据”指的是服务器传给客户的信息，或是当前客户端持有的信息。
*** 几种常见的状态
低功耗蓝牙有三种状态类型：外部状态，内部状态和抽象状态。
外部状态一般指物理测量指，比如传感器的温度，当前的电量。
内部状态是设备当前的工作状态。 
抽象状态是一种只和某一瞬间有关的状态信息，不反应设备当前的外部或内部状态, 比如命令灯光切换开关状态，要求设备立刻报警。在属性协议里，这些抽象状态称作控制点，一般不可读取但可被写入或被通知。
*** 状态机
有限状态机可以明确的使用属性协议和可公开的状态表示。状态机反映了设备的内部状态，并且有一个或多个外部的输入接口。这些外部输入为瞬时命令，根据其他状态信息或行为来改变状态机的状态，这是一个抽象状态，或称为控制点。
结合内部状态和控制点，便可完整地反映设备上有限状态机的工作流程和行为。可以从两个角度来看这种有趣的结合：
a. 通过公开有限状态机、它们的输入以及当前状态，可以明确的公开某设备的行为；通过开放的输入接口，其他设备可以与该设备交互。
b. 可以定义有限状态机的所有可能的行为，包括无效的行为；任何设备都可以通过任一控制点向状态机进行输入，而状态机将执行相应的预设行为。
[[file:images/statemachine.png]]

公开状态机使得无线传输信息变得更有效率，同时提高了互操作性，因为不可能命令状态机进入那些没有定义过的状态。因此，通过定义所有对的可能状态以及这些状态机在任何的输入下将执行的动作，便能实现一种最优的协议。
*** 服务和规范
低功耗蓝牙采用纯粹的“客户端一服务器”的结构，针对不同的用例对服务器和客户端的行为单独进行描述。服务器的行为在服务器规格书中定义，而用户的行为在另一规范说明中定义。通过一个属性数据库，服务器规格书定义了需要公开的状态以及通过属性可以实现的行为。
[[file:images/profileandservices.png]]

将服务器和客户端区分开的最大的好处是，服务器的行为将是预先定义并可知的，只会做服务说明中定义的“该做”的事情，不关心客户端怎样去使用它。
由于服务器的行为由服务定义，而不由规范定义，因此规范变的相当简单。客户端规范从本质上就是一组有关发现、连接、配置和使用各种服务的规则。客户端可用任意的服务组合来做不同的事情，例如使用时间服务的同时，又使用温度服务，可用在时间维度上键控温度的变化。

客户端对多种服务的组合正是低功耗蓝牙技术里最强的概念。每种单独的服务十分简单；而服务之间的不同组合提供了系统的复杂性和多样性。为了这个目标，服务必须是“原子”的。”原子“在这里指的事一种服务只执行特定的操作。
服务定义了设备如何交互，而规范不过是某些应用场合下执行交互的标准做法。
** 属性
要理解属性，首先要理解什么是属性。宽泛的讲，属性是一条带有标签、可以被寻址的数据。
*** 属性概述
属性由三种数值组成：属性句柄、属性类型和属性值:
| 2字节    | 2或6字节 | 0~512字节 |
| 属性句柄 | 属性类型 | 属性值    |
*** 属性句柄
一台设备可以有多个属性，这时就需要属性句柄来查找。
属性句柄是一个16位的地址，有效的句柄范围是（0x0001~0xFFFF)。0x0000是无效句柄，不能用于寻址。
可以把句柄想象为内存地址、端口号、属性值对应的硬件寄存器地址。
*** 属性类型
可以被公开的属性有许多类型：温度、压强、体积、状态机的状态等等。所有公开的数据的种类称作属性类型。为了区分如此多的数据类型，用一串128位的数字来标识属性的类型。这个唯一的标识码就叫做通用唯一识别码(UUID)。
一个典型的16字节UUID格式为XXXX-XX-XX-XX-XXXXXX。
蓝牙协议设定了一个蓝牙基础UUID： 00000000 – 0000 – 1000 – 8000 – 00805F9B34FB。
利用该基础UUID，可以使用16-bit或32-bit的UUID来代替128-bit的UUID，当传递到对端设备，再还原成128-bit的UUID。
假如16-bit的UUID为YYYY，则还原后的128-bit的UUID为：0000YYYY – 0000 – 1000 – 8000 – 00805F9B34FB。
假如32-bit的UUID为YYYYYYYY，则还原后的128-bit的UUID为：YYYYYYYY – 0000 – 1000 – 8000 – 00805F9B34FB。
ATT层支持使用16-bit和128-bit两种UUID，32-bit的UUID在使用前必须转换成128-bit。

这些属性类型分别对应了指定的UUID，BLE对这些UUID与属性类型的映射关系做了规定：
0x1800 – 0x26FF ：服务类通用唯一识别码
0x2700 – 0x27FF ：单位
0x2800 – 0x28FF ：属性类型
0x2900 – 0x29FF ：描述符类型
0x2A00 – 0x7FFF ：特征值类型
*** 属性值
属性值（Attribute Value）是存放数据的地方。如果是服务项或者特征值声明，该数据为UUID等信息，如果是普通的特征值，该数据则是用户的数据。
1. 服务通用唯一识别码
   每一种服务都能用一个UUID来辨认。可以是16位UUID也可以是128位UUID。
2. 单位
   定义相关单位的UUID
3. 属性类型
   基本属性类型，一般用于通用属性规范，而非具体的服务。
   BLE的属性类型是有限的，有四个大类：
   Primary Service（首要服务项）
   Secondary Service（次要服务项）
   Include（包含服务项）
   Characteristic（特征值）  
4. 特性描述符
   服务公开的额外信息。
5. 特性类型
   它是16位UUID中使用最多的一种。服务为公开的每一类数值都分配一个“特性类型“UUID。客户段从而能够发现服务器提供的所有不同类型的数据。每一个特性类型都有既定的格式和表达方法。
*** 数据库、服务器和客户端
一组属性的集合称为数据库。属性数据库总是位于属性服务器中。通过属性协议，属性客户端和属性服务器进行通信。对于BLE设备而言，由于强制要求属性数据库支持GAP服务，每一部低功耗蓝牙设备都包含有一个属性服务器和一个属性数据库。
*** 属性许可
一些属性服务器上的属性含有可读或可写的信息。为了提供这类访问限制，数据库中的每一个属性都含有一个许可。许可自身分为三种类型：使用许可，认证许可和授权许可。
属性许只适用于属性值，并不适用属性句柄和属性类型。
| 属性句柄	 | 属性类型               | 	属性值                   |
|   0x0001	 | 首要服务	       | GAP服务                          |
|   0x0002	 | 特性	           | 设备名                           |
|           0x0003 | 	设备名         | 	“接近标签”               |
|           0x0004 | 	特性           | 	外观                     |
|           0x0005 | 	外观           | 	标签                     |
|           0x0006 | 	首要服务       | 	GATT服务                 |
|           0x0007 | 	首要服务       | 	发射功率服务             |
|           0x0008 | 	特性           | 	发射功率                 |
|           0x0009 | 	发射功率       | 	-4dBm                    |
|           0x000A | 	首要服务       | 	立即报警服务             |
|           0x000B | 	特性           | 	报警级别                 |
|           0x000C | 	报警级别       |                                  |
|           0x000D | 	首要服务       | 	连接丢失服务             |
|           0x000E | 	特性           | 	报警级别                 |
|           0x000F | 	报警级别       | 	高                       |
|           0x0010 | 	首要服务       | 	电量服务                 |
|           0x0011 | 	特性           | 	电池余量                 |
|           0x0012 | 	电池余量       | 	75%                      |
|           0x0013 | 	特性表达格式   | 	8位无符号整形，0，百分比 |
|           0x0014 | 	特性           | 	电池余量状态             |
|           0x0015 | 	电池余量状态   | 	75%放电中                |
|           0x0016 | 	客户端特性配置 | 	0x0001                   |
定义的使用许可如下:
a. 可读
b. 可写
c. 可读并可写

定义的认证许可如下:
a. 需要认证
b. 不需要认证

定义的授权许可如下：
a. 无认证
b. 认证
授权和认证略有区别。客户端能够完全掌控发起认证的时机和方式。授权是服务器的一种行为，授权与否完全由服务器来决定，客户端对于授权不足无能为力。
*** 接入属性
客户端可以通过使用下列任意一种消息类型来访问属性数据库的各个属性：
1. 寻找请求
   客户端先使用“寻找请求”来寻找属性数据库中的属性，随后才能使用效率更高的基于句柄的请求。
2. 读取请求
   发送读取请求用以读取某个属性值。要确定读取的具体属性，应指定一个或多个属性句柄或者句柄范围，以及属性的类型。 
3. 写入请求
   发送写入请求用以携入某个属性值。该请求常常会使用一个属性句柄和要写入的数值。也可以事先准备多个需要写入的数值，然后在一个原子操作中一并写入。 

这里的任意一种请求都会使属性服务器发送一条响应。如果还需请求更多的数据，客户端还需发送另一条请求。为了降低服务器设备的复杂度，客户端一次只能发起一条请求，只有收到了上一条请求响应以后，才能发起下一条请求。

4. 写入命令
   通过写入命令来写入属性值。该命令不要求服务器回复。写入命令可以在任意时刻发送。这说明可以把命令写入公开的状态机的控制点。 
5. 通知
   通知可以在任意时刻发送，包含了要通知的属性句柄和当前的属性值。
6. 指示
   指示也包含了属性句柄和属性值。不同的是指示需要客户端回传一条属性确认信息。客户端通过回复确认信息，即表明了指示已经送达，还告诉服务器设备可以发起下一条指示；相比之下，通知可以在任意时刻发送。
*** 原子操作和事务
在客户端和服务器之间发送的每一条属性协议的信息都隶属于某个事务的一部分。事务可以是一条请求及其回应，也可以是一条指示及其确认信息。事务的重要性在于它限定了连续的事物之间需要保存的信息的数量。
这意味着当设备接收到一条请求后，它无须为了处理下一条请求而保存当前请求的任何信息。 
在一个事物结束之前不能发起新的事务。事务仅针对单个设备。发起事务的设备虽然不能初始化另一个事务，但可以处理其他配对设备的请求。 
1. 命令和通知 
借助于命令和通知，设备的已将信息发送给另一台设备，并在发起下一条命令或通知之前无需等待响应的响应。命令和通知完全可能被用来向对端设备发起泛洪攻击。 
2. 准备写入请求与执行写入请求 
使用准备写入请求和执行写入请求消息，设备可以准备一系列的写入操作并在一个事件中执行。从事件角度看，每一条准备写入请求及其响应属于一个单独事务。另外，在准备和执行操作的中途，允许插入其他请求。 
这种命令的两种用法：长写入和校验写入。这两种准备写入请求不仅包含了要写入的属性的句柄和值，还包含了需要写入的数值在目标属性中的偏移量。这意味着你可以在一次操作中用一系列的准备写入请求来写入某个很长的属性值的不同部分。另外准备写入请求的响应也包含了原请求中的属性句柄、偏移量和待写入部分的数值。表面看浪费了带宽，但由于响应中包含的信息必须和原请求相同，这能够避免错误的出现。
** 分组
属性规范定义了多组属性。 
面向对象编程中：接口是对外部行为的描述，类是对该接口的实现，对象是该类的实例 
在BLE中，服务和特性都用到了分组。使用服务声明来对服务进行分组，用特性声明对特性进行分组。服务是一种或多种特性的组合；特性则由一种或多种属性组成。
** 服务
BLE中，通用属性规范定义了两种基本的分组模式：服务分组模式和特性分组模式。服务等同于一个具有不可变接口的对象，一般包含一种或多种特性，并能引用其他服务。特性是数据的单位或公开行为的单位，这些特性是自解释的，一般的客户端能够读取、显示这些特性。 
一种服务只是一组特性和通过它们所公开的行为的集合。这些特性和它们对应的行为组成了服务的不可变的接口。
服务可以引用其他服务，赋予了该体系结构巨大的活力，实现更多的，更为多样的服务。
[[file:images/serviceAToServiceB.png]]


*** 扩展服务
服务A已经使用了多年，现需要扩展其功能。由于服务A是不可变的，无法简单的在原服务中添加新的行为。为了保证不改变原有服务的同时，进行必要的拓展。为此定义了新的服务AB，包含所需的扩展行为。不过为了保证成千上万的仅支持A的现有设备具备后向兼容性，也必须在每一部提供服务AB的设备上包含服务A的实例。(启示，在扩展功能的时候也可以参考一下)
[[file:images/serviceextend.png]]

*** 其他服务的重用
非常容易理解，当服务A想使用服务B的行为和状态信息，那么服务A只需用用服务B即可。类似于一个指向另一个类的实例的通用指针。
[[file:images/servicerefrence.png]]

*** 结合服务
当需要将与某个服务相关的两个独立的服务实例结合起来，并使其具备额外的行为。为了用服务满足这种需求，必须定义第三种服务，该服务分别引用了原来两个服务。
[[file:images/service%20composite.png]]

*** 首要服务次要服务
公开设备功能的服务通常属于首要服务。次要服务是一组无需用户理解的行为和特性的封装。 
通过建立“服务树”，首要服务在树的顶端，每一个分支指向首要服务或次要服务。
使用属性协议可以快捷地寻找到首要服务。次要服务只能通过引用来发现，必须通过另一个服务来指向它们。
[[file:images/servicefirsttosecond.png]]

*** 即插即用的客户端应用
可以使用某设备上的服务树的集合，并搜寻能使用这些服务树的应用。通用客户端会先进行一次完整的服务枚举：先是首要服务，随后是它们与所引用的服务之间的关系。一旦建立了服务树，就能将服务的“森林”递交给应用库，
由此获得能够与改服务森林的整体或局部协作的应用。
[[file:images/servicestree.png]]

*** 服务声明
使用服务声明对服务进行归类。服务声明的值是服务的UUID。设备可以安全的忽略掉任何不理解的服务。为了实现这一功能，属性协议允许利用属性句柄的范围来发现服务，但只进一步处理已知的服务。
[[file:images/servicedeclaration.png]]

*** 包含服务
次要服务必须逐个发现。为此，每一个服务可以有零或多个包含属性。包含的声明总是紧随着服务声明，并列于该服务的其他属性之前。包含的声明也包括了引用服务的句柄范围，以及引用服务的服务UUID。
[[file:images/servicecontain.png]]

蓝牙4.0BLE协议栈采用分层思路的最大优点是：将服务、接口和协议这三个概念明确的区分开来。服务说明某一层为上一层提供了一些什么样的功能；接口说明上一层如何使用下一层的服务；而协议涉及到如何实现本层的服务。这样，各层之间就具有很强的独立性，当协议的一部分发送变化时，只需对与此相关的分层进行修改即可，其他分层不需要改变。
** 特性
将一个服务的属性归类到一起，可以更好地说明这些属性的组合如何行为提供一致的接口。特性还需要指明数值的类型，数值是否可读或可写，如何配置数值的提示、通知、广播，数值的含义等。
特性由特性声明、特性数值和零个或多个描述符组成，声明包含了特性的所有其他属性，数值属性包含了该特性的实际值，描述符包含了该特性的附加信息或配置。
特性包含三个基本要素：声明、数值、描述符、
特性只是一个数值。特性首先从声明开始，包括了特性的所有其他属性;数值属性包含了该特性的实际值；而描述符包含了该特性的附加信息或配置。
***  特性声明
要建立一个特性，首先要用到特性属性，包含三个字段：特性性质、数值属性句柄和特性类型。 
[[file:images/character.png]]
特性性质是一个八位字段，确定了特性数值属性对一系列操作的支持情况，包括：读取、写入、通知、指示、广播、命令、签名认证。还包含一个扩展性质位。 
特性性质：
[[file:images/characterexample.png]]
数值句柄字段是包含特性数值的属性句柄。用户只需返回特性声明给服务器，后者使用该声明便可以立刻获取属性的数值。 
特性UUID用来识别特性数值的类型，该UUID类型必须和包含该特性数值的属性一致。
*** 特性数值
特性数值是一个属性，类型必须符合特性声明的特性UUID字段。
*** 描述符
特性可以包含如下的描述符：
1. 特性扩展性质
2. 特性用户描述
3. 客户端特性配置
4. 服务器特性配置
5. 特性表示格式
6. 特性聚合格式
** 属性协议
属性协议是非常简单的协议，客户端通过它可以发现并获取属性服务器上的属性。它由六种基本操作构成：
a. 请求
b. 响应
c. 命令
d. 指示
e. 确认
f. 通知

客户端通过向服务器发送请求，以要求服务器执行相关操作并进行响应。客户端一次只能发送一条请求。请求有两种可能的响应：与请求直接相关的响应；或是说明请求为何失败的错误响应。过程如下所示：
[[file:images/ATT.png]]

客户端也想服务器发送命令，但不一定会收到响应
[[file:images/ATTCommand.png]]

服务器通过向客户端发送指示，让客户端获悉某属性的数值。
[[file:images/ATTDirective.png]]

服务器以发送通知的形式来告知客户端某属性的数值。
[[file:images/ATTNotify.png]]
*** 协议消息
下表列出了属性协议中所有属性协议数据单元（PDU）：
[[file:images/PDU.png]]
*** 交换MTU请求
BLE中，属性协议默认的MTU（Maximum Transmission Unit，最大传输单元）长度为23字节。如果设备想发送更大的数据包，就要写上一个更长的MTU。交换MTU请求与交换MTU响应中发送的数值是固定的。
*** 查找信息请求
查找信息请求和回复用来查找一系列属性的句柄和类型信息。这是唯一一个能让客户端发现任意属性类型的消息。 
查找信息的请求包含起始句柄和结束句柄，定义了该请求用到的属性句柄范围。通常响应只能能够包含该范围内的部分句柄；为了查找所有的属性，必须使用一连串的查找信息请求，相邻请求中的起始、结束句柄前后相接。 
查找信息响应包含句柄-类型对。具有两种可能的格式，对应BLE使用的两种长度UUID：对于16位UUID，MTU默认为23字节，因此一个查找信息的响应最多包含5个句柄-类型对；对于128位UUID，只能包含一个句柄-类型对。更改MTU，所包含的句柄-类型对随之增加。
[[file:images/RequestInfo.png]]
*** 按类型值查找请求
使用按类型之查找请求和回复可以根据给定的类型和数值查找相应的属性。该请求包含两个句柄：起始句柄与结束句柄，定义了请求用到的属性句柄范围。对任意属性，当它的句柄处于起始与结束句柄范围内，并且具备了请求中所指定的类型和数值，那么该属性将在响应中被返回。 
按类型值查找请求主要用途是查找特定的首要服务。
用该请求也能够查找次要服务，不过当前的低功耗蓝牙不采用这样的方法。
*** 按类型读取请求
按类型读取请求能在句柄范围中读取某属性值。当客户端仅知道属性的类型而非句柄时可以使用该请求。请求包含了起始、结束句柄和需要读取的属性的类型。响应将给出符合的句柄和数值。 
按类型读取请求用于搜索已包含的服务，并通过特性类型来发现服务中所有的特性。可被用来读取已知类型的特性值。
符合请求的类型且落在句柄范围内的每一个属性都将被返回。
*** 读取请求
请求包含一个句柄，响应将返回该句柄对应的属性值。只有在客户端已知属性句柄的情况下，才能使用该请求读取属性值。
*** 大对象读取请求
有时属性值太长，无法装入一个读取响应，需使用大对象读取请求来获取剩余字节。大对象(Binary Large Object, BLOB)读取请求不光包含属性句柄，还包含属性值在整个数据中的偏移量。其相应将从属性偏移量开始，包含尽可能多的属性值。 
在获取了属性值前22字节后，假如客户端还想获取后续的属性值，则应使用大对象读取请求。下一条响应将返回第23个字节到第44个字节，如此继续，直到客户端读取到完整的属性值。 
该请求用于读取长特性值与长特性描述字。
*** 多重读取请求
多重读取请求用来在一个操作中读取多个属性值。该请求包含一个或多个属性句柄，响应则按照请求的顺序返回相应的属性值。如果客户端请求读取的属性值长度超过了响应数据包所能承载的最大长度，那么无法放入响应数据包的数值将被丢弃。
*** 按组类型读取请求
按组类型读取请求包含一个句柄的范围，读取时将其视为一个属性的类型来处理，只不过属性的类型必须为分组属性。其响应包含所读取的属性句柄、属性分组中最后一个属性以及属性的数值。
*** 写入请求
请求包含了一个句柄和打算写入该属性的数值。响应中将确认该数值已经被写入。
*** 写入命令
与写入请求类似，区别在于写入命令没有响应。
*** 签名写入命令
和写入命令类似，但包含认证签名。发送端可以在向服务器发送写入命令时认证自己，而无需加密通信连接。
签名写入命令适合用于以下两种场合：1. 发起加密将显著增加数据连接的延迟；2. 发起加密将显著增加简短且无需加密的数据的送达成本。
*** 准备写入请求与执行写入请求
准备写入请求与执行写入请求实现了两个功能：第一，它们提供了长属性值的写入功能；第二，允许在一个单独执行的原子操作中写入多个值。属性服务器包含一个准备写入队列，其中保存有准备写入请求。队列的大小可以独立配置，但通常它足够存储所有需要准备写入的服务。只有在收到执行写入请求时，准备写入的值才会写入属性。
和大对象读取请求类似，准备写入请求包含句柄、偏移量和部分属性值。这说明客户端既可以在队列中准备多个属性的值，也可以准备一个长属性值的各个部分。在真正执行准备队列之前，客户端可以确定所有部分都能写入服务器。 
准备写入响应也包含请求中所有的句柄、偏移量和部分属性值。之所以几乎偏执的重复这些数据是为了保证数据传递的可靠性。客户端可以对比响应和请求的字段值，保证准备的数据被正确的接收。 
一旦接收完所有的准备写入请求，服务器将拥有一个随时可以执行的准备写入队列。客户端发送标志位为“立即写入”的执行写入请求，随后服务器将在一次原子操作中写入所有值。属性将按照其准备的顺序写入。如果客户端多次准备了同一属性值，那么服务器将按照顺序向该属性写入这些值。可以使用准备队列来配置硬件状态。
*** 句柄值通知
句柄值指示类似于句柄值通知，有着相同的属性句柄字段和数值，不同的是需要客户端回复。服务器一次只能发送一条指示，并且之后收到确认响应后才发起下一条指示。 
句柄值确认不包含任何信息，主要用于流控。
*** 错误响应
当设备无法完成请求所要求的操作时，发送错误响应。错误响应包含导致错误的、和请求相关的所有信息。一旦客户端收到错误响应，它会认为该响应与其发送的最后一条请求相对应。一条错误将终止当前请求。如果客户端修复了该错误，客户端必须重新发起该请求。
下面是导致错误的不通原因：
1. 无效句柄
2. 不允许读取
3. 不允许写入
4. PDU 无效
5. 认证不足
6. 请求不支持
7. 偏移量无效
8. 授权不足
9. 准备队列已满
10. 属性不存在
11. 属性非大对象
12. 秘钥长度不足
13. 属性值长度无效
14. 未知错误
15. 加密不足
16. 组类型不支持
17. 资源不足
18. 应用错误
** 通用属性规范
属性的最后一个未解之谜是通用属性规范(GATT)规程。属性协议定义了客户端与服务器如何相互发送符合标准的消息，而GATT规程定义了如何发现与使用服务、特性与描述符的标准方法。GATT规程可以分为三种基本类型：
1. 发现规程
2. 客户端发起规程
3. 服务器发起规程
交换MTU规程不属于上述分组，它使用属性协议中的MTU交换请求来确定随后的消息所使用的MTU长度。
*** 发现规程
有四种基本对象需要发现。首先，客户端需要发现首要服务，一旦发现了首要服务，服务器上所有其他的隶属于该首要服务的信息都可以被发现。随后，客户端为每个首要服务设置句柄范围，已发现被引用的次要服务，以及该服务实例所公开的特性及其描述符。只有进行了上述操作，客户端才能使用这些服务，服务器发起规程才能使用该服务进行读写特征值或描述符的操作。
*** 发现服务
有三种发现服务的途径：
1. 发现所有首要服务
    当客户端连接设备后，为了发现设备上公开的所有首要服务来判断设备的功能，客户端可以使用按组类型读取请求，请求的句柄范围0x0001~0xFFFF并将属性类型设为首要服务。随后服务器把发现的首要服务回复给客户端。当中既包含服务声明的句柄，也包含该服务中属性的最后一个句柄。响应也包含该服务的声明内容，这样客户端便能理解每一种服务。 
    如果最后一个服务的最后一个句柄不是0xFFFF或者收到了错误响应，客户端将发送另一条按组类型读取请求。该请求的起始句柄紧随着上一条响应中最后一个服务的最后句柄，这样客户端便能够枚举设备上的所有服务。

2. 按服务UUID发现服务
   这种方式是手机端常用的。
   客户端向服务器发送按类型值查找请求，将句柄范围设为0x0001~0xFFFF，把类型设为首要服务，并把数值设为想获取的已知服务类型。随后服务器将响应所找到的每一个指定服务的句柄范围。
3. 查找包含服务
    一旦发现了首要服务，便能发现次要服务与其他的引用服务。这个过程要使用按类型读取请求来查找一个包含声明。此时，应将起始句柄与结束句柄设置为之前发现的服务的句柄范围。
*** 特性发现
在服务被发现以后，便可以发现每一个服务的特性。要获取完整的特性，需要发现特性和特性描述符。
1. 发现服务的所有特性 
   为了发现特性，使用按类型读取请求，将句柄范围设为该服务的句柄范围，并把类型设为特性，这样便能发现并读取所有的特性声明。 
   响应这能够将包含服务中每一个特性的声明和句柄。特性声明包含它的特征、承载特性值的属性句柄以及该特性的类型。这意味着一旦发现了特性声明便能获悉该特性表述的内容、该特性的功用以及后续读写规程所用到的句柄。
2. 发现所有特性描述符 
   发现了特性声明之后，便可以发现每一个特性的描述符。使用查找信息请求，将句柄范围设为归类于该特性的每一个特性声明的句柄范围。 
查找信息响应包含该特性的所有描述符的句柄和类型。客户端可以安全的忽略掉它们无法理解的特性描述符。
*** 客户端发起规程
对于特性，客户端可以执行四种相关操作：
1. 读取特性值
   在发现了服务的特性之后，便可以读取特性值。特性声明中的某个句柄指向了保存该特性值的属性。该属性的类型也和特性声明中的特性UUID一致。因此，一旦使用了之前描述的特性发现规程发现了特性描述符，特性值便能够通过读取请求或大对象读取请求读取。 
2. 使用特性UUID读取 
   使用按类型读取请求，并将类型设为所要求的特性UUID。例如读取电池电量，若能直接请求电池电量的特性值将大大提高效率。
3. 读取多重特性值
   如果已知每一个特性值的句柄，那么可以使用多重读取请求，同时读取多个特性值。每一个值之间没有特定的界限，因此必须知道每一个值的长度
4. 写入（长）特性值 
   写入请求被用来写入短特性值，默认的特性长度小于或等于20个字节。在使用该请求之前，必须先发现该特性值的属性句柄。 
   如果写入的属性值长度大于20个字节，需要准备写入请求来保存要写入的长值，以及执行写入请求用来真正执行写入操作。
5. 特性值可靠写入
   该规程使用了与写入长特征值规程中相同的准备写入请求与执行写入请求，稍有不同的是多了一个检验步骤，通过逐一比较准备写入响应与请求中的每一个值，保证了响应中的句柄和值与请求的完全一致。 
6. (签名) 无需响应写入
   有时，需要快速的将值写入，并且不需要协议层面的回复。此规程使用写入命令将需要写入的值发送给目标特性值属性。该命令没有响应。 
   对一些设备而言，向其写入数据时需要对该信息的发起者进行认证。为此用到了签名写入命令，同样不需要响应。认证提供了额外的安全性。
7. 读/写（长）特性描述符 
   特性描述符不同于特性值，但获取规程与读写特性值的规程类似。 
   读取请求与大对象读取请求用来读取描述符，写入描述符则用到了写入请求和准备写入请求以及执行写入请求
*** 服务器发起规程
有两种GATT规程是由服务器发起的：
1. 通知 
   通知是由服务器发起的消息，可以在任何时刻由服务器发给客户端。没有流控机制。如果客户端没有足够的缓存空间来保存，允许丢弃。通知使用句柄值通知消息。 
2. 指示
   同样由服务器发起的消息，包含流控机制，在服务器收到确认之前不能发送新的指示。指示使用句柄值只是消息和句柄值确认消息。
*** 属性协议数据单元(ATT PDU)到GATT规程的映射
[[file:images/ATTGATTMap.png]]
* 九、安全
** 安全概念
安全性包含了下列内容：
1. 认证
   下列两种基本方法：
   a. 初始认证和秘密共享
   b. 使用预先功效的秘密重新认证
2. 授权
   两种方式：
   a. 文档提供授权
   b. 直接进行授权
3. 完整性
4. 机密性
5. 隐私
6. 加密引擎
7. 共享机密
   低功耗蓝牙主要有五个秘钥：
   a. 临时秘钥(TK)
   b. 短期秘钥(STK)
   c. 长期秘钥(LTK)
   d. 身份解析秘钥(IRK)
   e. 连接签名解析秘钥(CSRK)
** 配对和绑定
配对有三个不同的阶段：
a. 配对信息交换
b. 链路认证
c. 秘钥分配
*** 配对信息交换
配对的第一阶段涉及配对信息的交换，该信息用于确定设备的配对方式。
从设备发起配对请求信息，主设备回复配对响应信息。
*** 认证
利用配对请求和配对响应所携带的信息，两个设备得以确定适合的配对算法。
*** 秘钥分配
连接了一旦利用STK加密，就可以分配所需的秘钥了。这些秘钥每次分配一个，因其长度为128位，灭一个数据包只能装进一个。
以下秘钥可以分配：
a. LTK
b. IRK
c. CSRK
** 绑定
绑定真正来说属于通用访问规范的讨论范畴。绑定指将秘钥及相关身份信息保存到安全数据库中。如果设备不保存这些值，他们虽能配对，但却不能绑定。只要当中某一个设备不保存，重新连接后，只有一个设备拥有
LTK, 因此加密的启动将会失败。
为了避免这种情况，两个设备在最初配对时就会交换绑定信息，从而能够清楚地知道对方是否保留了该绑定信息。如果对方设备不保存信息，那么一旦启动加密的尝试失败，主机将试图在次配对。
** 数据签名
第一次配对的时候交换CSRK(连接签名解析秘钥)。
* 十、通用访问规范
通用访问规范(GAP)定义了设备如何彼此发现、建立连接以及如何实现绑定，同时描述了设备如何成为广播者和观察者，以及实现无需连接的数据传输，还定义了如何用不同类型的地址来实现隐私性和可解析性。
** 背景
要理解低功耗蓝牙，最重要的是了解两个设备之间如何能发现对方、与对方协作以及不断找到对方并彼此连接。
*** 初次发现
为了发现一个设备，必须扫描有哪些正在广播的设备。多个广播设备向多个扫描设备发送数据包，构成一个多对多的拓扑结构。 
发现性包含两种类型：
有限可发现性: 由那些临时设置为可发现状态的设备使用。
一般可发现性: 由哪些最近没有执行过交互的可发现设备使用。

通过特定的过滤规则，获得设备列表。
*** 建立初始连接
一旦得到设备列表，并选中了其中的某些设备，下一步便是与该设备建立初始连接，即向广播报文提供的地址发起一个连接。如果设备建立了连接，可以穷举对端设备的所有服务和特性或只查找部分服务及其特性。 
服务发现最终将获得一个服务列表，包含对端设备公开的各种服务。客户端便可以使用这些服务。在应用商店模型中，由应用来完成接下来的特性发现和配置工作。特性发现与服务发现类似，设备可以枚举某一服务的所有特性，或者直接使用一些服务必须公开的公知特性。
*** 服务特性
为了实现设备间高效的数据传输，应使用通知和指示。如果客户端希望收到关于某特性的通知或指示，必须在客户端的特性配置描述符中写入信息，通过其启用所需的功能。于是，服务器设备在必要的时候将发送相应的通知或指示。
*** 长期关系
设备之间相关联俗称“绑定”。要完成绑定，需要将两个设备设置为可绑定。当其中一个设备打算进行绑定时，两个设备交换输入输出能力，选择一个认证算法，彼此身份验证，产生用于加密链路的STK（短期密钥）。链路加密完成后，进行共享机密的交换，用于与之前连结果的设备执行重连。
*** 重连
有时候设备完成了所有数据的发送，可能不愿再浪费能量保持连接而将其中断。
重连既简单又难。在低功耗蓝牙中，如果一个设备打算在重连后成为从设备，它必须通过可连接广播事件进行广播。然而，它既可能是不可发现设备，又可能是有限发现设备或一般可发现设备，还可能
不允许任何设备与之连接。与此同时，要与广播设备建立连接，主设备必须执行扫描并且向正在广播的特定地址发起连接。如果使用了白名单，那么该重连设备必须位于扫描设备或发起设备的白名单上。
*** 私有地址
私有地址是指周期性变化的设备地址。由于地址在随机变化，此时难以判断那个设备是否还在附近。
解决这个问题，需要执行三个步骤。第一步是在绑定时保存IRK秘钥；第二步是使用该秘钥生成一个可解析的私有地址；最后，主设备必须扫描所有设备，利用其所有的IRK解析每一个地址。只有能够验明
身份的地址才能进行连接。
** GAP角色
BLE设备定义了四类GAP角色：
1. 广播者
2. 观察者
3. 外围设备
4. 中央设备
广播者是发送广播报文的设备，通常广播一些服务数据给处于观察者角色的设备。必须有发射装置，但不一定有接收装置。
观察者是扫描广播者并将信息报告给应用的设备。必须有接收装置，但不一定有发射装置。
外围设备是利用可连接广播报文进行广播的设备。一旦连接将成为从设备，外围设备必须同时拥有发射和接收装置。
中央设备是向外围设备发起连接的设备。一旦连接将成为主设备，中央设备必须同时拥有发射和接收装置。
一个设备可以同时支持多个GAP角色，比如既可以是广播者，又可以同时为外围设备。
** 模式和规程
在GAP内部用模式(mode)和规程（procedure）来描述设备的行为。
当一个设备被配置为按照某种方式操作一段较长的时间时，称为模式。当一个设备被配置为在某一段有限的时间内执行某种特定的操作时，称为规程。
GAP定义了下列模式：
a. 广播模式
b. 不可发现模式
c. 有限可发现模式
d. 一般可发现模式
e. 不可连接模式
f. 定向可连接模式
g. 无向可连接模式
h. 不可绑定模式
i. 可绑定模式

GAP定义了下列规程：
a. 观察规程
b. 有限发现规程
c. 一般发现规程
d. 名称发现规程
e. 自动连接建立规程
f. 一般连接建立规程
g. 选择性连接建立规程
h. 直接连接建立规程
i. 连接参数更新规程
j. 终止连接规程
k. 绑定规程

要理解GAP，就必须理解上述模式和规程是如何互相操作的。
*** 广播模式和观察规程
设备处于广播模式时，将使用链路层广播信道和广播数据包发送数据。使用观察规程的设备能够获得该广播数据。
一些设备可能只装备了发射装置，通常不能在广播数据中使用私有地址或者签名的数据。因为二者均需要密钥的相关信息，它们只可能在连接建立后的绑定过程中进行分配，这既需要发射装置有需要接收装置。
*** 可发现性
在GAP中，只有外围设备才允许被发现。尝试发现外围设备的那些设备处于中央角色。
为了提供不同的可发现性，外围设备有三种工作模式：不可发现模式、有限可发现模式和一般可发现模式。不可发现模式并不意味着不允许发送广播数据，而是指即使对端设备发现了该设备，其用户界面也不会发出通知。
GAP要求可发现设备必须在其广播数据里包含有关可发现性的信息，从而与那些发送不可发现信息的广播设备区分开来。
**** 不可发现模式
AD信息标识不必放在广播数据中，除非设置其他信息。
不可发现模式是默认值，主机需要执行命令才能将该默认模式变为其他任意一种模式。
**** 有限可发现模式
AD Bit0置位，Bit1清除。
有限可发现模式大概只能维持30s的时间。
由于有限可发现模式主要用于打算被发现并且进入连接的设备，因此强烈建议在广播数据中包含下列信息，以帮助接收者构建用户界面：
1. 发射功率值AD，用于计算路径损耗，判断距离以实现排序
2. 本地名称AD，用于显示设备的名称
3. 服务AD，用于根据设备支持的功能对设备进行过滤
有限可发现设备应该按照合理的广播间隔执行广播，一方面便于快速生成用户界面，另一方面减少BLE主设备的扫描时间。
**** 一般可发现模式
AD Bit0清除，Bit1置位。当设备打算被发现时，应该使用一般可发现模式。
和有限可发现模式的不同点：
1. 一般可发现设备的可发现时间没有限制；有限可发现设备最多维持该模式30s。
2. 一般可发现设备建议的广播时间间隔更长，介于1.28s和2.56s之间；而有限可发现设备介于250ms和500ms之间。
发现一般可发现设备需要较长的时间。其广播数据包也应包含发射功率值以及其他用于构造用户界面的信息。
**** 可发现性
希望找到可发现外设的中央设备，可以使用有限可发现规程或一般可发现规程。除了基于AD信息标识执行的过滤操作不同，这两个规程基本一样。
如果广播数据包没有AD信息标识，或者虽然存在该信息，但既不含有限可发现模式位也不含一般可发现模式位，则视为该广播者为不可发现设备，且不会被发现。
如果AD信息标识设置为有限可发现模式位，则设备总是可发现的，无论使用有限可发现规程还是一般可发现规程。
如果AD信息标识设置为一般可发现模式位，仅当使用一般可发现规程时，该外围设备才是可发现的。
一般可发现规程将发现所有可发现的外围设备，有限可发现规程仅仅能够发现有限可发现的外围设备。
|                  | 有限可发现规程 | 一般可发现规程 |
| 有限可发现模式位 | 发现           | 忽略           |
| 一般可发现模式位 | 发现           | 发现           |
*** 可连接性
在GAP中，只有处于外围角色的设备才可使用可连接模式。尝试连接外围设备的那些设备处于中央角色，使用连接建立规程。
就可连接性而言，可连接的外围设备可处于下列三种模式：不可连接模式、定向可连接模式和无向可连接模式。对中央设备而言，存在四种不同的连接建立规程：自动、一般、选择性和定向连接建立规程。
链路层提供了两种类型的可连接广播报文：ADV_IND和ADV_DIRECT_IND，以及连种类型的不可连接广播报文：ADV_NONCONN_IND和ADV_SCAN_IND。主机总是可以根据它的连接模式选择正确的广播报文类型。
**** 不可连接模式
处于不可连接模式的设备，只能使用ADV_NONCONN_IND和ADV_SACN_IND两种广播报文类型。不可连接模式是默认模式，要将外围设备变为可连接，需要主机执行指定的操作。
**** 定向可连接模式
定向可连接模式用于快速连接中央设备，该模式采用ADV_DIRECT_IND广播报文，不含主机的广播数据，因此无法与可发现模式相结合。
定向广播报文发送频率很快，该模式最多持续1.28s，超时之后不允许主机立刻重启该模式，否则会干扰其他设备。
ADV_DIRECT_IND广播报文既包含当前外围设备的地址，有包含中央设备的地址。外围设备必须曾经与中央设备建立过连接才能获悉其地址。
**** 无向可连接模式
一个可连接的外围设备如果无需快速建立连接，或者打算尽可能的节省电量，则可以使用无向连接模式。该模式采用ADV_IND广播报文，包含AD信息标识，因此设备处于可发现模式的同时，也可处于无向连接模式。
**** 自动连接建立规程
自动连接建立规程用来向多个设备同时发起连接。为实现同时向多个设备发起连接，中央设备的主机首先必须生成白名单，其中包括应与之建立连接的设备的集合，再根据白名单发起连接。通常，主机使用已绑定设备集作为白名单。一旦找到其中设备，使用定向可连接模式或者无向可连接模式的主机即可建立连接。如果还需要与其他外设链接，自动连接建立规程将再次启动。该规程有两个缺点：只能使用一套基本连接参数；不能连接使用私有地址的设备。
**** 一般连接建立规程
该规程不使用白名单，采用被动扫描寻找所有的广播设备。
对于使用可解析私有设备的地址，它们的地址将于所有IRK进行匹配，以便找出中央设备打算连接的那些设备。
该规程的缺点在于，在主机发现广播设备和开始直接连接之间，需要一定的处理时间；一般连接建立规程还需要主机处理控制器收到的所有广播报文，比自动连接建立规程消耗的能量多。
**** 选择连接建立规程
该规程用来向多个设备发起连接，但设备的连接参数各不相同。
执行选择连接建立规程，主机首先将连接设备集放入白名单，而后启用白名单并开始扫描。正在广播的外围设备只有在白名单上的才会被提交给主机，而该区域的其他设备会被控制器过滤。
对于白名单上的设备，主机可以从控制器收到其广播信息。它首先检查该设备是否使用可连接广播数据包类型，如果是，主机就停止扫描使用定向连接建立规程向该地址发起连接。
与一般连接建立规程相比，缺点至少耗费两个广播报文才可建立连接；与自动建立规程相比，解决了单一连接参数问题，但没有解决私有地址解析带来的私有性问题。
**** 定向连接建立规程
该规程采用一套特有的连接参数与指定设备建立连接。
该规程直接向单个设备地址发起连接，不再考虑白名单。
*** 绑定
绑定模式两种：不可绑定模式和可绑定模式
规程：绑定规程
**** 不可绑定模式
设备的默认模式为不可绑定模式，此时设备不接受绑定，不交换也不存储密钥。
**** 可绑定模式
设备如果想被绑定，必须处于可绑定模式。此时它将接受对端设备的绑定请求。要进入可绑定模式，在配对请求消息的认证需求中，应设置绑定位。
**** 绑定规程
希望与其他可信设备进行绑定的设备可以使用绑定规程。当使用绑定规程时，设备将发起配对，并在配对请求消息的认证需求中设置绑定位。
具体而言，使用可绑定规程的设备应发起配对并设置绑定位，如果对等设备是可绑定的，它将回复响应并同样设置可绑定位。一切顺利的话，密钥将在链路加密之后进行相互分发并被存储起来。
密钥的分发和存储是设备已绑定的标识。
** 安全模式
GAP定义了两类安全模式和三个安全等级。第一类安全模式用于在连接内部提供不同级别的加密，第二类安全模式用于提供不同级别的数据签名保护。
这两类安全模式被服务用于描述其所需的安全性级别。
安全模式和级别的定义如下：
1. 安全模式1 等级1：无安全性
2. 安全模式1 等级2：带加密的未认证配对
3. 安全模式1 等级3：带加密的认证配对
4. 安全模式2 等级1：带数据签名的未认证配对
5. 安全模式2 等级2：带数据签名的认证配对

在使用更高级安全级别的链路中，可以传输较低安全模式和安全级别的数据。
表：安全模式和级别
|                 | 未加密链路且为认证配对      | 未加密链路但认证配对 | 加密链路但为认证配对        | 加密链路且认证配对 |
| 安全模式1 级别1 | 发送数据                    | 发送数据             | 发送数据                    | 发送数据           |
| 安全模式1 等级2 | 加密并发送数据              | 加密并发送数据       | 发送数据                    | 发送数据           |
| 安全模式1 等级3 | 不可能---须通过认证配对修复 | 加密并发送数据       | 不可能---须通过认证配对修复 | 发送数据           |
| 安全模式2 等级1 | 使用认证密钥签名数据        | 使用认证密钥签名数据 | 发送数据                    | 发送数据           |
| 安全模式2 等级2 | 不可能---须通过认证配对修复 | 使用认证密钥签名数据 | 不可能---须通过认证配对修复 | 发送数据           |
** 广播数据
设备在发送广播报文时，必须遵循固定的广播数据格式或扫描响应数据格式。开始处均含有一个长度字段，用来表示该结构其余部分的字节长度，紧接着是广播数据类型字段。
*** 标识
标识AD是位字段的序列，可以从0字节到若干字节的任意长度。在广播数据之外的任意字节默认值均为“0”。
BLE定义了如下标识：
a. 有限可发现模式
b. 通用可发现模式
c. 不支持BR/EDR
d. 设备同时支持LE和BR/EDR（控制器）
e. 设备同时支持LE和BR/EDR（主机）
*** 服务
有很多不同类型的服务广播数据类型，每种类型公开了一个服务UUID列表。UUID包括两种大小：裁剪的16位值以及完整的128位值。
四种不同的服务广播数据类型：
q. 16位服务UUID完整列表
b. 16位服务UUID部分列表
c. 128位服务UUID完整列表
d. 128位服务UUID部分列表
*** 本地名称
本地名称的广播数据类型共有两类：
a. 完整的本地名称
b. 裁剪的本地名称
当本地名称太长而无法放入一个广播报文中时，使用裁剪的本地名称数据类型。本地名称是UTF-8字符串，允许截断。
*** 发射功率等级
发射功率等级广播数据类型是指传输该广播数据包时采用的功率值，长度1个字节，单位dBm。
*** 从设备连接间隔范围
从设备连接间隔范围代表外围设备倾向的连接间隔。利用从设备连接间隔范围，中央设备能够获得外围设备倾向的连接间隔的参考值，用于发起连接。间隔参数包括两个16位的值，第一个为最小连接间隔，第二个为最大连接间隔。
*** 服务请求
服务列表包括了外围设备希望中央设备支持的服务。该服务请求为正在搜寻外围设备的中央设备提供了连接能力，它们能够据此判断那些外围设备最有可能包含和服务对应的客户端功能。 
服务请求广播数据包括16位服务UUID或128位服务UUID的部分列表。
*** 服务数据
设置广播服务时，使用的是“服务数据”广播数据类型。服务数据的起始两个字节是16位UUID，表示服务号，其他字节为实际的服务数据。
*** 制造商指令数据
数据的起始两个字节为16位的公司标志，接着是公司指定的数据。
** GAP 服务
GAP定义了通用属性规范服务，为服务提供了一种确定信息的方式。服务提供了下列五项特性：
a. 设备名
b. 外观
c. 外围设备隐私标志
d. 重连地址
e. 外围设备首选连接参数
*** 设备名特性
设备名特性是一个UTF-8字符串，表示设备的名称。由于一个设备只允许一个设备名特性，直接使用按UUID都去请求便能快速获得设备名，无需首先执行服务发现或者特性发现。
*** 外观特性
外观特性是要给16位的值，用来列举设备的外观样式。该特性值为枚举类型，在编号分配文件中定义。
外观特性通常被用来用户界面的设备旁边显示设备的图标。
*** 外围设备隐私标识
外围设备隐私标识表示设备是否正在使用隐私。该特性即可读又可写。只有当存在重连地址并且隐私标志设置为“启用”时，设备才能真正实现带隐私的重连。
*** 重连地址
重连地址用于外围设备与曾经绑定的中央设备进行重连，且该中央设备知道外围设备启用了隐私的情况。重连地址为不可解析的私有地址，在每次重连时更换。
使用时，重连地址应为不可解析的私有地址。这样一来，要想真正找到与之对应的外围设备，只能是哪些曾经与改外围设备进行了绑定且读取了其重连地址的设备。
*** 外围设备首选连接参数
外围设备通过外围设备首选连接参数特性公开这些参数，因此中央设备不用猜测这些具体参数，只需在首次连接时读取它们，并尽快调整连接参数即可。


profile:
[[file:images/profile.png]]

* 十一、中央设备
BLE的应用分为两类：一类为中央设备而设计，用于找到并与外围设备进行交互；另一类为外围设备而设计，用于向中央设备上运行的应用提供信息。
** 背景
中央设备对于BLE的应用而言至关重要，它们往往具有丰富的功能和复杂的用户界面。
** 发现设备
中央设备的一个首要任务是发现其他设备。要实现这一目标，既可以使用被动扫描，也可以使用主动扫描。被动扫描是指中央设备被动的侦听来自外围设备的广播报文，主动扫描是指侦听到外围设备后中央设备向其询问更多信息。
如果中央设备仅需了解周围有些什么设备，或者携带了哪些信息，则应当使用被动扫描。如果中央设备还需生成一个用户界面，则应使用主动扫描。
通过扫描可以发现的信息不但有设备名称，还有用来识别设备的唯一标识。中央设备可以利用该标识连接到对端设备。此外，在扫描响应包中还可能包含一些服务有关的有用信息，比如电池的电量或当前时间。
有些信息难以通过扫描立即获得，但可以在快速连接到对端设备之后进行读取。
** 连接设备
在发起连接时，首先根据两台设备的要求选择连接参数。通常外围设备有一个“客户端首选连接参数”特性，以便向中央设备提供明确的提示信息。在初次连接时，这些信息还不可用。因此初次连接时所选用的参数需要在降低功耗和加快货的设备特性之间取得某种折中。
最佳参数集往往具有较小间隔的连接间隔，这样初次连接时能够很快地交换属性协议和链路层的控制信息；此外还应有相对较大的从设备延迟，以便外围设备尽可能地节省能量。
** 这个设备能做什么
中央设备连接到外围设备后，为了收集设备服务信息，将依次执行四个规程：首要服务发现、关系发现、特性发现以及描述符发现。
第一个规程是首要任务发现，这些服务描述了设备的作用。
接下来，由于中央设备已知的每个首要服务还能包含其他服务，需要进一步发现这些关系，包括延伸、组合、重用等。
一个设备拥有的服务及不一定决定外围设备支持的规范集。只要发现了服务，就可以发现特性集及其描述符。
*** 通用客户端
可以制造一种完全通用的客户端，按照人类可读的格式来读取和显示特征值。这给予了中央设备一种能力，即使不理解外围设备的某些服务或特性，也能够将其展现给用户。通用客户端包含两个层面：第一层可以直接使用外围设备的可用信息，第二层在可用信息的基础上，通过互联网获得更多的信息。
处于第一层的通用客户端会发现外围设备上的所有特性，过滤掉不能直接读取的特性，以及那些没有特性显示格式描述符的特性。
处于第二层的通用客户端可以显示最复杂的特性值。第二层的通用客户端不依赖于特性显示格式描述符，而是利用了每一个特性类型都有的唯一编号UUID。在SIG网站中可以查找数据格式的XML表示。
一个连接互联网的通用客户端首先会获得可读的特性值，向网站执行一个简单查询，下载描述特性的XML文件，最后再通过这个文件向用户显示数值。
*** 与服务交互
一旦确定与外围设备上的服务进行交互，中央设备将连接到该设备，并开始读写特性值和描述符。上述操作通过属性协议进行，该协议本质上是一种无状态的协议。
**** 可读特性
最基本的服务只是简单的公开了一组可读的特性。基本服务用起来非常容易，只要客户端理解服务的某个特性，便可以读取相应的数值。对于长度较短的值只要一个读取请求，对于较长的值则需要多个读取请求。
**** 可写特性
较为复杂的情况是服务既包含可读特性，又包含可写特性。客户端可以随时检查服务的当前状态，而不用记忆之前做过什么。这在客户端的应用程序意外终止时格外有用。重新启动后，客户端可以通过读取相应的特性值来更新对方的状态。
**** 控制点
还有一种服务类型虽然不保存状态，但客户仍然可以向该服务写入值。服务将立即使用写入的值，在其被消耗之后不必存储该值。这种特性称为控制点。
基于控制点的服务类型所具有的优势在于，设备不用理会是哪个从设备在对控制点发号施令，只需要按照写入控制点的指令进行操作即可。
**** 状态机
反映状态机状态的的服务类型公开了一些可写控制点和一个或多个可读的特性。状态机具有一个公开的状态，并提供了一种从内部或外部改变状态的方法。状态机和控制点的唯一区别在于：状态机会将状态保存起来。
**** 通知和指示
客户端可以在服务器上配置特性来发送所需的通知。大多数通知发送由服务来定义，但其中一些还可以通过特性描述符进一步配置。某些特性不支持通知，只有那些有正确属性以及有客户端配置描述符的特性才可以支持。通知是不可靠的。
客户端可以配置特性发送指示。指示和通知类似，唯一的不同是指示需要客户端向服务器发送一条确认消息，告知数据已经被应用程序成功接收。指示同样是利用客户但配置描述符来进行配置的。
** 绑定
较之简单连接，一些设备需要维持更长时间的连接，还有些设备希望秘密的传输数据，或者与曾经认证过的设备，而非当前区域里的可用设备通信。这可以通过使用安全模型来实现，从根本上说是利用“绑定”。
如果客户端向与其他设备建立长期通信关系，首先应连接该设备，找到一些能用的服务，然后启动一个安全连接。这些安全连接显示认证该设备为正确的设备，再对连接进行加密以确保机密性。最后，设备交换一些配对信息：如果客户端存储了该配对信息，就与对端设备完成了绑定。
绑定的重要性在于，当客户端重新连接到该设备时，并不需要再次认证身份或交换配对信息，而只需要将部分绑定信息用于连接加密。于是设备之间变建立了一个认证的、保密的数据连接。
** 变更服务
中央设备（客户端）能够记住或缓存不同连接的服务集和特性集。有些设备将有能力改变或增加服务。当发生这种情况时，客户端将不能读取任何属性，所有到该服务器的请求都会失效。这保护了客户端不会读取到错误的属性。
伴随着错误信息，客户端还会收到来自GATT的服务变更通知。由于客户端已经保存了这个属性句柄，收到通知后便可以执行适当的操作。
服务变更通知包含一些列已被更改的句柄。这意味着，如果设备指示增加或删除一个服务，那么通知里将只含有这个服务的句柄范围。如果该设备改变了所有的服务，那么设备里将包括所有服务的句柄范围。
服务变更只与绑定的设备密切相关。如果中央设备没有和外围设备绑定，则不能缓存属性句柄，也收不到任何服务变更的通知。换言之，对于两个未绑定设备来说，客户端必须在每次连接时刷新服务器整个服务列表和特性列表。
** 实现规范
在设计一个中央设备时，最关注的时它支持的功能。通常情况下，中央设备将实现一个或多个客户端的角色，支持若干规范。
*** 定义规范
规范是针对给定用例的设备功能描述。规范也称为配置文件，在其中规定了角色。规范的不同角色作为设备生态系统的不同部分，保证了规范的正常运作。每个规范角色定义了一套设备必须实现的服务。
*** 查找服务
一个规范需要做的第一件事，就是找到对端设备支持的服务。首先必须发现首要服务，具体来说就是要么根据服务类型查找首要服务，要么查找所有的首要服务。
通常情况下，复杂的客户端会一次性的发现服务器的所有服务，将其缓存以便稍后使用。假如实现了某个规范的应用要求获得对端的所有服务，客户端将直接向其提供缓存的服务列表。因为即使服务器上的服务集发生变化，它会向客户端发送一个通知，告知服务已经改变。
*** 查找特性
一旦发现了对端设备的服务集，接下来就是发现相关特性集。和服务一样，规范既可能只需一个特性，也可能需要许多特性。由于有的特性可能是可选的，因此必须在服务内搜寻它们，以检查其是否存在。
*** 使用特性
发现特性之后就可以使用它们。
由于一些服务只有一个可读特性，特性的发现和特性值的读取可以组合到一起，变成一个操作。
有些特性可以支持通知或指示。客户端如果要使用这些服务器功能，必须先找到客户端特性配置描述符。这需要客户端在获得特性值之后查找同一特性的其他属性，以便找到所有特性相关的描述符。一旦发现客户端特性配置描述符，即可向其写入正确的值，从而启用通知或指示。
*** 规范安全
如果客户端打算断开连接以便未来快速重新连接，或者特性需要加密或认证链路，那么客户端和服务器之间必须要进行绑定。绑定通常是由规范中的客户端来发起的。客户端可以尝试读取或写入服务中的任一特性值。只要其拥有读取或写入的正确权限，服务器将会响应原有的特性值或响应写入的值；如果权限不正确，服务器会回应一个适当的错误代码。
如果错误码表明客户端的安全性不足，客户端可能会尝试与服务器进行配对或绑定，以获得正确的安全级别。如果只需进行一次信息的读取，配对通常就可以；如果需要多次重连，则还需进行绑定。一旦设备获得了适当的安全性，连接将被加密，客户端可以重试先前失败的请求。
* 十二、外围设备
** 背景
中央设备通常是电话、电视或者电脑，而外围设备则是为超低功耗实施了高度优化的定制产品。外围设备的工作离不开与中央设备进行交互。交互的方式有三种：
a. 广播数据
b. 被中央设备发现并与之建立连接
c. 断开连接，然后在需要时建立连接
** 仅广播
使用广播模式可以实现与其他设备的数据共享，且功耗最低。
一个只进行广播的外围设备可以非常省电。不需要被连接或被发现——不需要接受任何来自中央设备的数据，也不用维持庞大的属性数据库以便被发现——只是不断广播有用的数据而已。
广播的间隔或频率是必须考虑的一个因素, 根据具体的需求来决定。
** 可发现
除了仅做广播的设备，所有其他的设备都是可发现的。可发现意味着外围设备的广播目标是在此区域的正在扫描的所有中央设备。
可发现有两种类型：有限可发现性和一般可发现性。
在于用户交互后，外围设备只能在一小段时间内处于有限可发现状态，其他所有时候将会处于一般可发现状态。
外围设备并不总是处于可发现状态。
** 可连接
可发现和可连接彼此非常类似，都使用广播报文，但服务于不同的目的。可发现的设备通常不与任何其他设备配对，而可连接的设备通常与一个或多个设备绑定，并且只接受来自这些设备的连接。
当设备处于可连接状态，它将接受来自发起设备的连接请求。从本质上讲，一个可连接的外围设备能接受来自任何设备的连接请求报文。为了解决这种全盘接受的方法带来的问题，外围设备上的控制器可以配置为只接受有限的若干中央设备的连接请求。中央设备列表存储在白名单中, 如果发起连接设备不在其中，该请求将被忽略。
接受以绑定的、位于白名单中的设备请求连接，先决条件在于设备自身必须执行过绑定。在此之前，该设备将处于混杂模式，接受任何设备的连接。这通常在设备首次设为可连接但是还未与任何设备绑定的时候才发生。
** 公开服务
进入连接，外围设备通常会公开一个或多个服务。每个服务都封装了外围设备中某个组成部分的原子行为。服务通过服务器的属性公开，服务器上属性的集合统称为属性服务库。
属性由通用属性规范（GAP）来组织，其结构如下：
属性数据库中的每个服务都始于一个服务声明，其中定义了服务的类型，紧随其后的是隶属于该服务的每个属性。接下来又是下一个服务的服务声明。
在每个服务中可以包含一个或多个其他服务，在提供更复杂的行为的同时，避免了拓展服务的核心功能。
在每个服务中可以有一个或多个特性。从根本上说，特性是可以访问的一个值。每个特性都有特性声明，用来说明数据到底是什么或者怎样可以访问它；特性也可以包括额外的信息，描述它是如何被格式化或者如何配置的。
上述的服务声明、服务包含、特性声明、特性值和特性描述符等都是属性数据库内的单个属性。因此，外围设备只需要根据它想公开的行为决定需要公开的属性，然后等待客户端来与这些属性交互。
** 特性
特性是服务的基础建筑模块。一个特性即为一个客户端能够交互的值。特性值的格式由特性的类型决定，并最终由一个XML特性规格书文件决定。
特性的行为不在该XML特性规格书中定义，而在服务规范中定义。因此，在一个外围设备里可以有多个类型相同但行为各异的特性。
** 安全事项
外围设备公开的数据可能是一些机密信息或隐私信息，只能将其发送到那些通过了认证的设备。为了确保这一点，属性服务器一旦认为请求达不到当前的安全级别，将拒绝任何有关属性信息的请求。
认证和绑定是由中央设备首先发起的。设备一经验证，连接将被加密，客户端的请求可以被重新发送。外围设备的属性服务器每收到一个请求，首先检查接受请求所需的安全权限。
服务或特性所要求的安全性是有具体实现的服务规范来定义的。
** 为低功耗优化
对于使用微型电池供电的外围设备，为了延长其使用时间，必须考虑为低功耗操作进行优化。包括确定最佳广播间隔和连接间隔、优化属性方位、选择是否保持连接还是断开重连等。
外围设备的典型状态：
[[file:images/lowpower.png]]
当设备首次启动，外围设备将进入可发现广播状态，在该状态下能够被一个或多个中央设备发现。
在某个时刻，一个中央设备将会连接到外围设备并与之绑定。绑定成功后，外围设备进入可连接广播状态。如果绑定没有发生，外围设备将回到可发现广播态，等待另一个中央设备的连接和绑定。
已绑定的外围设备将执行可连接广播，于是，只有与之配对的中央设备才能连接到该外围设备。它们一旦重新连接就进入了连接状态，中央设备会根据自身的意图来管理连接的间隔。
处于连接的外围设备需要明确是该保持连接还是该现在断开？如果选择断开连接，外围设备有可能进入下列两种状态：一是回到可连接广播，即周期性的发送广播报文以便中央设备根据其需要发起重连；二是关闭广播，直到外围设备有数据要发送时再使用定向广播与中央设备重新建立连接。
外围设备上还可能有个“连接”按钮，一旦按下，设备将删除当前绑定信息，重新变为可以被发现的设备。此时，任何与之相连的设备都将被断开，外围设备将返回可发现广播状态。
*** 可发现广播
在外围设备中，一个优化功耗的根本办法在于为广播和连接精心选择时间的间隔。
一开始，外围设备通常会执行可发现广播，以便让中央设备发现自己。一旦连接成功，该设备只会执行可连接广播。
位于可发现模式时，外围设备希望尽快被发现。设备同时也会广播大量的附加信息。
一个可发现的外围设备更倾向于使用较快的频率发送广播。
*** 绑定
每当外围设备建立了连接，连接的时间间隔将由中央设备决定。中央设备应该设置合理的连接间隔值。
处于可发现广播状态的外围设备能够以相当快的连接间隔建立连接。
一旦绑定完成，并且中央设备已完成对外围设备的分析，此时应该尽量减少连接的间隔以节省能量。
*** 定向广播
一些情况发生时，外围设备可能会选择与中央设备直接连接。对外围设备而言，自事件发生到通知中央设备之间的时间必须尽可能短。最佳选择时使用定向广播。
定向广播对能量有较大损耗，此时的外围设备将以非常快的频率向某个中央设备发送大量的广播报文。如果该中央设备正准备向外围设备发起连接，连接会立即建立，外围设备能够迅速的发送所需数据。
定向广播是外围设备连接中央设备的最快方式。
定向广播不允许设置广播间隔。因为广播报文必须每隔3.75ms在三个广播信道发送一遍。
对于那些需要快速发送数据、但很少处于可连接状态的设备，定向广播将是最佳模式。
*** 已连接
在连接中，中央设备对于外围设备所使用的时间间隔和延迟具有完全控制权。外围设备则有向中央设备提出要求的权利，可通过L2CAP的信令信道，向中央设备建议更适合的连接参数。
涉及功耗的连接参数主要有两个：连接间隔和从设备延迟。连接间隔并不是最重要的因素，从设备延迟对于外围设备的功耗而言更为关键。
从设备延迟是指从设备可以忽略的主设备连接间隔的数量，它是一个0~500之间的整数。
增大从设备延迟并不能无限制的提高节能收益：从设备延迟过大，从设备通过降低同步频率所节省的能量会损失在窗口扩展中（时钟不精确）。
外围设备必须收发一些空报文，即当主设备发送一个80us的报文时，从设备将回复一个同样长的报文。随着从设备延迟的增加，用于接收和发送数据包的时间变得微不足道，从设备通过减低同步频率所节省
的能量损失在了窗口扩展中。
*** 保持连接还是断开
外围设备进入连接之后，实际用例有可能要求数据以随机的间隔执行传输。具有这类用途的外围设备既可以保持连接，又可以断开连接，随后等待有数据时再重新连接。
这里需要判断两个因素：首先外围设备开始广播，中央设备能否在一个合理时间内重连，让用户不至于察觉到连接已经断开；其次，如果保持连接，应该使用多大的连接延迟，电池寿命允许的连接延迟范围又是多少。
为了外围设备做出更明智的决策，外围设备可以公开“扫描参数”服务，以便中央设备向其告知扫描使用的参数。在中央设备连接到外围设备时，它会发现上述服务并且写入一个延迟值，等到重新建立连接时在兑现改延迟。
利用这一信息，在结合用户体验的要求，外围设备可以确定是否该断开连接，以及该何时断开。
** 优化属性
通常，外围设备公开一个或多个服务，中央设备发现这些服务及其特性和描述符。然后，中央设备读取、写入或配置这些特性，从而使用由外围设备提供的服务。外围设备也可以通过实现与特性有关的通知和指示，帮助自己节省能量。
特性和服务是通过属性来描述的，并且通过属性协议来访问。该协议使客户端（位于中央设备）能够访问外围设备的属性，不仅支持属性的读取和写入，而且支持属性的通知和指示。
通过为尽可能多的特性提供通知或指示，外围设备可以帮助自己进一步节能，也为中央设备提供了更多可配置通知或指示的特性。




